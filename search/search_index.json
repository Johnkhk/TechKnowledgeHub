{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Blog/Documentation","text":"<p>This site showcases various design patterns in multiple programming languages and system design concepts.</p>"},{"location":"design-patterns/design-patterns/","title":"Overview","text":""},{"location":"design-patterns/design-patterns/#creational-patterns","title":"Creational Patterns","text":""},{"location":"design-patterns/design-patterns/#structural-patterns","title":"Structural Patterns","text":""},{"location":"design-patterns/design-patterns/#behavioral-patterns","title":"Behavioral Patterns","text":""},{"location":"design-patterns/creational/factory-method/","title":"Factory Method Pattern","text":""},{"location":"design-patterns/creational/factory-method/#description","title":"Description","text":"<p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don\u2019t worry: the objects are still created via the new operator, but it\u2019s being called from within the factory method. Objects returned by a factory method are often referred to as products.</p>"},{"location":"design-patterns/creational/factory-method/#benefits","title":"Benefits","text":"<ol> <li> <p>Decoupling Object Creation: The Factory Method Pattern separates the process of creating an object from the rest of the code, making the codebase more modular and easier to manage.</p> </li> <li> <p>Single Responsibility Principle: By centralizing the object creation code in one place, the Factory Method Pattern adheres to the Single Responsibility Principle, as the classes do not need to know the details of object creation.</p> </li> <li> <p>Flexibility and Extensibility: This pattern provides flexibility by allowing the creation of objects without specifying the exact class of the object that will be created. It also makes the code more extensible by allowing new classes to be added without modifying existing code.</p> </li> <li> <p>Enhanced Maintainability: By using the Factory Method Pattern, changes in the object creation process affect only the factory code, making the system easier to maintain and update.</p> </li> <li> <p>Code Reusability: The Factory Method Pattern promotes code reuse by enabling the creation of objects through a common interface, which can be used across different parts of the application.</p> </li> </ol>"},{"location":"design-patterns/creational/factory-method/#example","title":"Example","text":"<p>Imagine you are building a notification system that needs to send notifications through different channels such as email, SMS, and push notifications. The type of notification to be sent depends on user preferences, and you want to encapsulate the notification creation logic in a single place.</p> <p>In this example:</p> <ul> <li>The NotificationFactory is the Factory.</li> <li>The Factory Method Pattern ensures that the application creates the appropriate type of notification based on user preferences.</li> <li>This approach simplifies the notification creation process and makes it easier to add new notification types in the future.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#implementation","title":"Implementation","text":"<ul> <li>All notifications have a <code>send()</code> method (business logic), so <code>Notifications</code> is the base class, <code>EmailNotifcation</code> and <code>SMSNotification</code> inherit from the base and must implement their custom business logic.</li> <li>The <code>NotificationFactory</code> is also a base (abstract) class, <code>ConcreateNotificationFactory</code> which can be <code>SMSNotificationFactory</code> or <code>EmailNotificationFactory</code> will implement <code>createNotification() -&gt; Notification</code> separately.</li> <li>So in runtime, depending on which product you want to create, you'd instantiate that factory and create it.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Notification {\n        +send(content: str): void\n    }\n\n    class EmailNotification {\n        +send(content: str): void\n    }\n\n    class SMSNotification {\n        +send(content: str): void\n    }\n\n    class NotificationFactory {\n        Abstract +createNotification(): Notification\n    }\n\n    class ConcreteNotificationFactory {\n        +createNotification(): Notification\n    }\n\n    Notification &lt;|-- EmailNotification\n    Notification &lt;|-- SMSNotification\n    NotificationFactory &lt;|-- ConcreteNotificationFactory\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Notification(ABC):\n    @abstractmethod\n    def send(self, content: str):\n        pass\n\n\nclass EmailNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending email with content: {content}\")\n\n\nclass SMSNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending SMS with content: {content}\")\n\n\nclass NotificationFactory(ABC):\n    @abstractmethod\n    def create_notification() -&gt; Notification:\n        # can add complex shared logic here\n        pass\n\n\nclass EmailNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return EmailNotification()\n\n\nclass SMSNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return SMSNotification()\n</code></pre> <pre><code>package implementation\n\n// uses a gun example (only has one concrete factory &amp; method with product impl using if statement)\nimport \"fmt\"\n\n// iGun.go declare the interface for the gun\ntype IGun interface {\n    SetName(name string)\n    SetPower(power int)\n    GetName() string\n    GetPower() int\n}\n\n// gun.go concrete gun struct\ntype Gun struct {\n    name  string\n    power int\n}\n\nfunc (g *Gun) SetName(name string) {\n    g.name = name\n}\n\nfunc (g *Gun) GetName() string {\n    return g.name\n}\n\nfunc (g *Gun) SetPower(power int) {\n    g.power = power\n}\n\nfunc (g *Gun) GetPower() int {\n    return g.power\n}\n\n// ak47.go declares the struct for the AK47 gun\ntype Ak47 struct {\n    Gun\n}\n\nfunc newAk47() IGun {\n    return &amp;Ak47{\n        Gun: Gun{\n            name:  \"AK47 gun\",\n            power: 4,\n        },\n    }\n}\n\n// musket.go declares the struct for the musket gun\ntype musket struct {\n    Gun\n}\n\nfunc newMusket() IGun {\n    return &amp;musket{\n        Gun: Gun{\n            name:  \"Musket gun\",\n            power: 1,\n        },\n    }\n}\n\n// gunFactory.go declares the factory method to get the gun\nfunc GetGun(gunType string) (IGun, error) {\n    if gunType == \"ak47\" {\n        return newAk47(), nil\n    }\n    if gunType == \"musket\" {\n        return newMusket(), nil\n    }\n    return nil, fmt.Errorf(\"Wrong gun type passed\")\n}\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from factory_method import (\n    Notification,\n    SMSNotification,\n    EmailNotification,\n    SMSNotificationFactory,\n    EmailNotificationFactory,\n)\n\n\nemail_factory = EmailNotificationFactory()\nemail_notification = email_factory.create_notification()\nemail_notification.send(\"Hello via Email!\")\n\nsms_factory = SMSNotificationFactory()\nsms_notification = sms_factory.create_notification()\nsms_notification.send(\"Hello via SMS!\")\n\n# tests\nassert isinstance(email_notification, Notification)\nassert isinstance(email_notification, EmailNotification)\nassert isinstance(sms_notification, Notification)\nassert isinstance(sms_notification, SMSNotification)\n</code></pre> <pre><code>package implementation_test\n\nimport (\n    \"testing\"\n    impl \"tkh/code/design-patterns/creational/factory-method/go/implementation\"\n)\n\nfunc TestGetGun(t *testing.T) {\n    ak47, err := impl.GetGun(\"ak47\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if ak47.GetName() != \"AK47 gun\" {\n        t.Errorf(\"expected AK47 gun, got %s\", ak47.GetName())\n    }\n    if ak47.GetPower() != 4 {\n        t.Errorf(\"expected power 4, got %d\", ak47.GetPower())\n    }\n\n    musket, err := impl.GetGun(\"musket\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if musket.GetName() != \"Musket gun\" {\n        t.Errorf(\"expected Musket gun, got %s\", musket.GetName())\n    }\n    if musket.GetPower() != 1 {\n        t.Errorf(\"expected power 1, got %d\", musket.GetPower())\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/","title":"Singleton Pattern","text":""},{"location":"design-patterns/creational/singleton/#description","title":"Description","text":"<p>The Singleton Pattern ensures a class has only one instance and provides a global point of access to it. This pattern is useful when exactly one object is needed to coordinate actions across the system.</p>"},{"location":"design-patterns/creational/singleton/#benefits","title":"Benefits","text":"<ol> <li> <p>Controlled Access to a Single Instance: The Singleton Pattern ensures that there is precisely one instance of a class, which is particularly useful when managing shared resources like configuration settings or logging.</p> </li> <li> <p>Reduced Namespace Pollution: By providing a single point of access, the Singleton Pattern avoids the proliferation of global variables and reduces the risk of naming conflicts.</p> </li> <li> <p>Lazy Initialization: Singleton can be initialized only when it's needed, rather than when the application starts. This can lead to better resource management.</p> </li> <li> <p>Global Access Point: Singleton provides a global access point to an instance, making it easy to use and access the singleton instance throughout the application.</p> </li> <li> <p>Consistency: Ensures that all components of an application use the same instance, leading to consistent behavior and state across the application.</p> </li> <li> <p>Resource Management: Useful for managing limited resources, such as database connections or thread pools, by ensuring that only one instance is used to manage these resources.</p> </li> </ol>"},{"location":"design-patterns/creational/singleton/#example","title":"Example","text":"<p>Imagine you are building a web application that needs to interact with a database. Creating a new database connection every time a request is made would be inefficient and resource-intensive. Instead, you can use the Singleton Pattern to ensure that only one database connection is created and shared across the entire application.</p> <p>In this example:</p> <ul> <li>The database connection is the Singleton.</li> <li>The Singleton Pattern ensures that the application creates only one database connection and uses it for all database operations.</li> <li>This approach improves performance by reducing the overhead of establishing multiple connections and ensures consistent access to the database.</li> </ul>"},{"location":"design-patterns/creational/singleton/#implementation","title":"Implementation","text":"<ul> <li>The Singleton Class's contructor is normal - does everything a normal contructor would do, except it is <code>private</code>!</li> <li><code>getInstance()</code> static method that returns the instance<ul> <li>if no instance, (acquire thread lock if parallel), call private constructor</li> <li>otherwise return instance</li> </ul> </li> </ul>"},{"location":"design-patterns/creational/singleton/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Singleton {\n        -static instance: Singleton\n        -Singleton()\n        +static getInstance(): Singleton\n    }\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Singleton:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:  # check if the static instance already exists\n            # calls __new__ method of the parent (object) class\n            # basically calling object.__new__(Singleton)\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not hasattr(self, \"initialized\"):\n            self.initialized = True  # Avoid reinitialization\n            self.value = 42\n\n    # Public methods (business logic)\n    def get_value(self):\n        return self.value\n\n    def set_value(self, value):\n        self.value = value\n</code></pre> <pre><code>package implementation\n\nimport (\n    \"sync\"\n)\n\n// lowercase singleton struct so it is not accessible outside the package (not exported)\ntype singleton struct {\n    value int\n}\n\n// declare package level variables\nvar (\n    instance *singleton // Pointer to the singleton instance (initialized to nil)\n    once     sync.Once  // used to ensure the singleton is created only once (even with goroutines) (initialized to zero value of sync.Once)\n)\n\n// GetInstance returns the singleton instance of singleton\nfunc GetInstance() *singleton { // returns a pointer to the singleton instance\n    once.Do(func() {\n        // instance is set to the address of a new singleton instance with value 42\n        // singleton's constructor is private, so it can only be created within the package\n        instance = &amp;singleton{value: 42}\n    })\n    return instance\n}\n\n// GetValue returns the value of the singleton instance\nfunc (s *singleton) GetValue() int {\n    return s.value\n}\n\n// SetValue sets the value of the singleton instance\nfunc (s *singleton) SetValue(value int) {\n    s.value = value\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from singleton_implementation import Singleton\n\n# Example usage\nsingleton1 = Singleton()\nsingleton2 = Singleton()\n\n# Ensure both variables point to the same instance\nassert singleton1 is singleton2\n\n# Ensure the initial value is correct\nassert singleton1.get_value() == singleton2.get_value() == 42\n\n# Set a new value using one instance\nsingleton1.set_value(100)\n\n# Ensure both instances reflect the new value\nassert singleton1.get_value() == singleton2.get_value() == 100\n\nprint(\"Singleton works correctly!\")\n</code></pre> <pre><code>package usage\n\nimport (\n    // Standard library packages\n    \"testing\"\n\n    // External package\n    impl \"tkh/code/design-patterns/creational/singleton/go/implementation\"\n)\n\nfunc TestSingleton(t *testing.T) {\n    singleton1 := impl.GetInstance()\n    singleton2 := impl.GetInstance()\n\n    // Ensure both variables point to the same instance\n    if singleton1 != singleton2 {\n        t.Errorf(\"Expected singleton1 and singleton2 to be the same instance, but they are not\")\n    }\n\n    // Ensure the initial value is correct\n    if singleton1.GetValue() != 42 || singleton2.GetValue() != 42 {\n        t.Errorf(\"Expected initial value to be 42, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // Set a new value using one instance\n    singleton1.SetValue(100)\n\n    // Ensure both instances reflect the new value\n    if singleton1.GetValue() != 100 || singleton2.GetValue() != 100 {\n        t.Errorf(\"Expected value to be updated to 100, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // log that we are done testing\n    t.Log(\"Done testing singleton\")\n}\n</code></pre>"}]}