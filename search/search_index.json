{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Blog/Documentation","text":"<p>This site showcases various design patterns in multiple programming languages and system design concepts.</p>"},{"location":"design-patterns/design-patterns/","title":"Overview","text":""},{"location":"design-patterns/design-patterns/#creational","title":"Creational","text":"<ul> <li>Singleton</li> <li>Factory Method</li> <li>Abstract Factory</li> <li>Builder</li> <li>Prototype</li> <li>Object Pool</li> </ul>"},{"location":"design-patterns/design-patterns/#structural","title":"Structural","text":"<ul> <li>Adapter</li> <li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Facade</li> <li>Flyweight</li> <li>Proxy</li> </ul>"},{"location":"design-patterns/design-patterns/#behavioral","title":"Behavioral","text":"<ul> <li>Chain of Reponsibility</li> <li>Command</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>State</li> <li>Strategy</li> <li>Template</li> <li>Visitor</li> </ul>"},{"location":"design-patterns/creational/abstract-factory/","title":"Abstract Factory Pattern","text":""},{"location":"design-patterns/creational/abstract-factory/#description","title":"Description","text":"<p>The abstract factory pattern is for creating families of related objects - (abstract classes). The key difference is that the Factory Method pattern is used to create one type of product, while the Abstract Factory pattern is used to create families of related products. The Abstract Factory pattern uses multiple factory methods to create different products.</p>"},{"location":"design-patterns/creational/abstract-factory/#benefits","title":"Benefits","text":"<ol> <li>Encapsulation of Object Creation: The Abstract Factory pattern encapsulates the creation of related objects in one central place, making the code more modular and easier to manage.</li> </ol>"},{"location":"design-patterns/creational/abstract-factory/#example","title":"Example","text":"<p>Imagine you are developing a user interface toolkit that needs to support multiple themes such as Light and Dark themes. Each theme includes several components like buttons and checkboxes that need to look and behave consistently. By using the Abstract Factory pattern, you can create a family of components for each theme.</p> <p>In this example:</p> <ul> <li>The <code>UIFactory</code> is the Abstract Factory.</li> <li>The <code>LightUIFactory</code> and <code>DarkUIFactory</code> are concrete factories that produce components specific to their themes.</li> <li>Each factory creates a family of products, such as Button and Checkbox, ensuring that all components in a theme are consistent.</li> </ul> <p>note: The factory method example focuses on creating a single type of product (Notification Factory) based on some criteria. - while here in UI Facory, you jave <code>createButton</code> and <code>createCheckbox</code>. Then you can have Light and Dark UI factory as concrete - while in factory method you have <code>createEmail</code> and <code>createSMS</code>...</p>"},{"location":"design-patterns/creational/abstract-factory/#implementation","title":"Implementation","text":"<ul> <li>All UI components implement a common interface, for example, <code>Button</code> and <code>Checkbox</code>.</li> <li>The UIFactory is an abstract class with methods like <code>createButton()</code> and <code>createCheckbox()</code>.</li> <li>Concrete factories like LightUIFactory and DarkUIFactory implement these methods to create theme-specific components.</li> </ul>"},{"location":"design-patterns/creational/abstract-factory/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Button {\n        +render(): void\n    }\n\n    class Checkbox {\n        +render(): void\n    }\n\n    class UIFactory {\n        Abstract +createButton(): Button\n        Abstract +createCheckbox(): Checkbox\n    }\n\n    class LightButton {\n        +render(): void\n    }\n\n    class DarkButton {\n        +render(): void\n    }\n\n    class LightCheckbox {\n        +render(): void\n    }\n\n    class DarkCheckbox {\n        +render(): void\n    }\n\n    class LightUIFactory {\n        +createButton(): Button\n        +createCheckbox(): Checkbox\n    }\n\n    class DarkUIFactory {\n        +createButton(): Button\n        +createCheckbox(): Checkbox\n    }\n\n    Button &lt;|-- LightButton\n    Button &lt;|-- DarkButton\n    Checkbox &lt;|-- LightCheckbox\n    Checkbox &lt;|-- DarkCheckbox\n    UIFactory &lt;|-- LightUIFactory\n    UIFactory &lt;|-- DarkUIFactory\n    LightUIFactory --&gt; LightButton\n    LightUIFactory --&gt; LightCheckbox\n    DarkUIFactory --&gt; DarkButton\n    DarkUIFactory --&gt; DarkCheckbox\n</code></pre>"},{"location":"design-patterns/creational/abstract-factory/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Button(ABC):\n    @abstractmethod\n    def render(self):\n        pass\n\n    @abstractmethod\n    def onClick(self):\n        pass\n\n\nclass Checkbox(ABC):\n    @abstractmethod\n    def render(self):\n        pass\n\n    @abstractmethod\n    def onChange(self):\n        pass\n\n\nclass DarkButton(Button):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering dark button with content: {self.content}\")\n\n    def onClick(self):\n        print(f\"Dark button with content: {self.content} was clicked\")\n\n\nclass DarkCheckbox(Checkbox):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering dark checkbox with content: {self.content}\")\n\n    def onChange(self):\n        print(f\"Dark checkbox with content: {self.content} was changed\")\n\n\nclass LightButton(Button):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering light button with content: {self.content}\")\n\n    def onClick(self):\n        print(f\"Light button with content: {self.content} was clicked\")\n\n\nclass LightCheckbox(Checkbox):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering light checkbox with content: {self.content}\")\n\n    def onChange(self):\n        print(f\"Light checkbox with content: {self.content} was changed\")\n\n\nclass UIFactory(ABC):\n    @abstractmethod\n    def createButton(self, content: str):\n        pass\n\n    @abstractmethod\n    def createCheckbox(self, content: str):\n        pass\n\n\nclass darkUIFactory(UIFactory):\n    def createButton(self, content: str):\n        return DarkButton(content)\n\n    def createCheckbox(self, content: str):\n        return DarkCheckbox(content)\n\n\nclass lightUIFactory(UIFactory):\n    def createButton(self, content: str):\n        return LightButton(content)\n\n    def createCheckbox(self, content: str):\n        return LightCheckbox(content)\n</code></pre> <pre><code>package abstract_factory\n\nimport \"fmt\"\n\n// Button interface\ntype Button interface {\n    Render()\n    OnClick()\n}\n\n// Checkbox interface\ntype Checkbox interface {\n    Render()\n    OnChange()\n}\n\n// DarkButton struct\ntype DarkButton struct {\n    Content string\n}\n\nfunc (b DarkButton) Render() {\n    fmt.Printf(\"Rendering dark button with content: %s\\n\", b.Content)\n}\n\nfunc (b DarkButton) OnClick() {\n    fmt.Printf(\"Dark button with content: %s was clicked\\n\", b.Content)\n}\n\n// DarkCheckbox struct\ntype DarkCheckbox struct {\n    Content string\n}\n\nfunc (c DarkCheckbox) Render() {\n    fmt.Printf(\"Rendering dark checkbox with content: %s\\n\", c.Content)\n}\n\nfunc (c DarkCheckbox) OnChange() {\n    fmt.Printf(\"Dark checkbox with content: %s was changed\\n\", c.Content)\n}\n\n// LightButton struct\ntype LightButton struct {\n    Content string\n}\n\nfunc (b LightButton) Render() {\n    fmt.Printf(\"Rendering light button with content: %s\\n\", b.Content)\n}\n\nfunc (b LightButton) OnClick() {\n    fmt.Printf(\"Light button with content: %s was clicked\\n\", b.Content)\n}\n\n// LightCheckbox struct\ntype LightCheckbox struct {\n    Content string\n}\n\nfunc (c LightCheckbox) Render() {\n    fmt.Printf(\"Rendering light checkbox with content: %s\\n\", c.Content)\n}\n\nfunc (c LightCheckbox) OnChange() {\n    fmt.Printf(\"Light checkbox with content: %s was changed\\n\", c.Content)\n}\n\n// UIFactory interface\ntype UIFactory interface {\n    CreateButton(content string) Button\n    CreateCheckbox(content string) Checkbox\n}\n\n// DarkUIFactory struct\ntype DarkUIFactory struct{}\n\nfunc (f DarkUIFactory) CreateButton(content string) Button {\n    return DarkButton{Content: content}\n}\n\nfunc (f DarkUIFactory) CreateCheckbox(content string) Checkbox {\n    return DarkCheckbox{Content: content}\n}\n\n// LightUIFactory struct\ntype LightUIFactory struct{}\n\nfunc (f LightUIFactory) CreateButton(content string) Button {\n    return LightButton{Content: content}\n}\n\nfunc (f LightUIFactory) CreateCheckbox(content string) Checkbox {\n    return LightCheckbox{Content: content}\n}\n</code></pre>"},{"location":"design-patterns/creational/abstract-factory/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from abstract_factory import darkUIFactory, lightUIFactory\n\n\ndef usage(mode: str):\n    dark_ui_factory = darkUIFactory()\n    light_ui_factory = lightUIFactory()\n\n    if mode == \"dark\":\n        button = dark_ui_factory.createButton(\"Dark button\")\n        checkbox = dark_ui_factory.createCheckbox(\"Dark checkbox\")\n    elif mode == \"light\":\n        button = light_ui_factory.createButton(\"Light button\")\n        checkbox = light_ui_factory.createCheckbox(\"Light checkbox\")\n\n    button.render()\n    button.onClick()\n    checkbox.render()\n    checkbox.onChange()\n</code></pre> <pre><code>package abstract_factory\n\nfunc main() {\n    var factory UIFactory\n\n    // Use the DarkUIFactory\n    factory = DarkUIFactory{}\n    button := factory.CreateButton(\"Dark Mode\")\n    checkbox := factory.CreateCheckbox(\"Dark Mode\")\n    button.Render()\n    button.OnClick()\n    checkbox.Render()\n    checkbox.OnChange()\n\n    // Use the LightUIFactory\n    factory = LightUIFactory{}\n    button = factory.CreateButton(\"Light Mode\")\n    checkbox = factory.CreateCheckbox(\"Light Mode\")\n    button.Render()\n    button.OnClick()\n    checkbox.Render()\n    checkbox.OnChange()\n}\n</code></pre>"},{"location":"design-patterns/creational/builder/","title":"Builder Pattern","text":""},{"location":"design-patterns/creational/builder/#description","title":"Description","text":"<p>Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.</p> <p>Let's say you are building a house - all houses need 4 walls, floor, roof and door. But some houses want a backyard, heating, etc. You don't want to create a million subclasses and you also don't want a big constructor (with a bunch of null calls). </p> <p>Note: Having a director class is also optional, but it can help with organizing construction routines. </p>"},{"location":"design-patterns/creational/builder/#benefits","title":"Benefits","text":"<ol> <li>Controlled Construction Process: The Builder pattern allows you to construct objects step by step, providing more control over the construction process and making it easier to create complex objects.</li> </ol>"},{"location":"design-patterns/creational/builder/#example","title":"Example","text":"<p>Let's say you want to build all types of houses. </p> <p>In this example:</p> <ul> <li>The <code>House</code> is the complex object we want to create.</li> <li>We want to build a wooden house or brick house - each requires a different setup for the foundation. (due to material)</li> <li>We might also want a luxury or basic house. The <code>Director</code> can take care of this.</li> </ul>"},{"location":"design-patterns/creational/builder/#implementation","title":"Implementation","text":"<ul> <li>The complex object <code>House</code> has a default constructor initializing all its fields to <code>None</code>. The fields will include all types of possible houses. </li> <li>The <code>HouseBuilder</code> is our basic builder interface.</li> <li><code>WoodenHouseBuilder</code> and <code>BrickHouseBuilder</code> are our concrete house builders.</li> <li>The <code>Director</code> can <code>construct_simple_house()</code> or <code>construct_luxury_house()</code> or <code>construct_house_with_3_bedrooms()</code>, etc. </li> <li><code>build_backyard(type)</code> can take a type too to mix and match!</li> <li>The steps methods return the builder so we allow for chanining calls. </li> </ul>"},{"location":"design-patterns/creational/builder/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class House {\n        +foundation: str\n        +structure: str\n        +roof: str\n        +rooms: str\n        +backyard: str\n    }\n\n    class HouseBuilder {\n        +build_foundation(): HouseBuilder\n        +build_structure(): HouseBuilder\n        +build_roof(): HouseBuilder\n        +build_rooms(number: int): HouseBuilder\n        +build_backyard(type: str): HouseBuilder\n        +build(): House\n    }\n\n    class WoodenHouseBuilder {\n        +build_foundation(): WoodenHouseBuilder\n        +build_structure(): WoodenHouseBuilder\n        +build_roof(): WoodenHouseBuilder\n        +build_rooms(number: int): WoodenHouseBuilder\n        +build_backyard(type: str): WoodenHouseBuilder\n        +build(): House\n    }\n\n    class BrickHouseBuilder {\n        +build_foundation(): BrickHouseBuilder\n        +build_structure(): BrickHouseBuilder\n        +build_roof(): BrickHouseBuilder\n        +build_rooms(number: int): BrickHouseBuilder\n        +build_backyard(type: str): BrickHouseBuilder\n        +build(): House\n    }\n\n    class Director {\n        +construct_simple_house(): House\n        +construct_luxury_house(): House\n        +construct_house_with_3_bedrooms(): House\n    }\n\n    HouseBuilder &lt;|-- WoodenHouseBuilder\n    HouseBuilder &lt;|-- BrickHouseBuilder\n    Director --&gt; HouseBuilder\n</code></pre>"},{"location":"design-patterns/creational/builder/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass House:\n    def __init__(self):\n        self.foundation = None\n        self.structure = None\n        self.roof = None\n        self.rooms = None\n        self.backyard = None\n\n    def __str__(self):\n        return (\n            f\"House with foundation: {self.foundation}, structure: {self.structure}, \"\n            f\"roof: {self.roof}, rooms: {self.rooms}, backyard: {self.backyard}\"\n        )\n\n\nclass HouseBuilder(ABC):\n    @abstractmethod\n    def build_foundation(self):\n        pass\n\n    @abstractmethod\n    def build_structure(self):\n        pass\n\n    @abstractmethod\n    def build_roof(self):\n        pass\n\n    @abstractmethod\n    def build_rooms(self, number):\n        pass\n\n    @abstractmethod\n    def build_backyard(self, type):\n        pass\n\n    @abstractmethod\n    def build(self):\n        pass\n\n\nclass WoodenHouseBuilder(HouseBuilder):\n    def __init__(self):\n        self.house = House()\n\n    def build_foundation(self):\n        self.house.foundation = \"Wooden Foundation\"\n        return self\n\n    def build_structure(self):\n        self.house.structure = \"Wooden Structure\"\n        return self\n\n    def build_roof(self):\n        self.house.roof = \"Wooden Roof\"\n        return self\n\n    def build_rooms(self, number):\n        self.house.rooms = f\"{number} Wooden Rooms\"\n        return self\n\n    def build_backyard(self, type):\n        self.house.backyard = f\"Wooden {type} Backyard\"\n        return self\n\n    def build(self):\n        return self.house\n\n\nclass BrickHouseBuilder(HouseBuilder):\n    def __init__(self):\n        self.house = House()\n\n    def build_foundation(self):\n        self.house.foundation = \"Concrete Foundation\"\n        return self\n\n    def build_structure(self):\n        self.house.structure = \"Brick Structure\"\n        return self\n\n    def build_roof(self):\n        self.house.roof = \"Concrete Roof\"\n        return self\n\n    def build_rooms(self, number):\n        self.house.rooms = f\"{number} Brick Rooms\"\n        return self\n\n    def build_backyard(self, type):\n        self.house.backyard = f\"Brick {type} Backyard\"\n        return self\n\n    def build(self):\n        return self.house\n\n\nclass Director:\n    def __init__(self, builder):\n        self._builder = builder\n\n    def construct_simple_house(self):\n        self._builder.build_foundation().build_structure().build_roof().build_rooms(2)\n        return self._builder.build()\n\n    def construct_luxury_house(self):\n        self._builder.build_foundation().build_structure().build_roof().build_rooms(\n            5\n        ).build_backyard(\"Luxury\")\n        return self._builder.build()\n</code></pre> <pre><code>package builder\n\nimport (\n    \"fmt\"\n)\n\ntype House struct {\n    Foundation string\n    Structure  string\n    Roof       string\n    Rooms      string\n    Backyard   string\n}\n\nfunc (h House) String() string {\n    return fmt.Sprintf(\"House with foundation: %s, structure: %s, roof: %s, rooms: %s, backyard: %s\",\n        h.Foundation, h.Structure, h.Roof, h.Rooms, h.Backyard)\n}\n\ntype HouseBuilder interface {\n    BuildFoundation() HouseBuilder\n    BuildStructure() HouseBuilder\n    BuildRoof() HouseBuilder\n    BuildRooms(number int) HouseBuilder\n    BuildBackyard(typ string) HouseBuilder\n    Build() House\n}\n\ntype WoodenHouseBuilder struct {\n    house House\n}\n\nfunc (b *WoodenHouseBuilder) BuildFoundation() HouseBuilder {\n    b.house.Foundation = \"Wooden Foundation\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildStructure() HouseBuilder {\n    b.house.Structure = \"Wooden Structure\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildRoof() HouseBuilder {\n    b.house.Roof = \"Wooden Roof\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildRooms(number int) HouseBuilder {\n    b.house.Rooms = fmt.Sprintf(\"%d Wooden Rooms\", number)\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildBackyard(typ string) HouseBuilder {\n    b.house.Backyard = fmt.Sprintf(\"Wooden %s Backyard\", typ)\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) Build() House {\n    return b.house\n}\n\ntype BrickHouseBuilder struct {\n    house House\n}\n\nfunc (b *BrickHouseBuilder) BuildFoundation() HouseBuilder {\n    b.house.Foundation = \"Concrete Foundation\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildStructure() HouseBuilder {\n    b.house.Structure = \"Brick Structure\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildRoof() HouseBuilder {\n    b.house.Roof = \"Concrete Roof\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildRooms(number int) HouseBuilder {\n    b.house.Rooms = fmt.Sprintf(\"%d Brick Rooms\", number)\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildBackyard(typ string) HouseBuilder {\n    b.house.Backyard = fmt.Sprintf(\"Brick %s Backyard\", typ)\n    return b\n}\n\nfunc (b *BrickHouseBuilder) Build() House {\n    return b.house\n}\n\ntype Director struct {\n    builder HouseBuilder\n}\n\nfunc (d *Director) ConstructSimpleHouse() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(2).Build()\n}\n\nfunc (d *Director) ConstructLuxuryHouse() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(5).BuildBackyard(\"Luxury\").Build()\n}\n\nfunc (d *Director) ConstructHouseWith3Bedrooms() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(3).BuildBackyard(\"Standard\").Build()\n}\n</code></pre>"},{"location":"design-patterns/creational/builder/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from builder import WoodenHouseBuilder, BrickHouseBuilder, Director\n\n# Client code\nwooden_house_builder = WoodenHouseBuilder()\nbrick_house_builder = BrickHouseBuilder()\n\ndirector = Director(wooden_house_builder)\nsimple_wooden_house = director.construct_simple_house()\nprint(simple_wooden_house)\n\ndirector = Director(brick_house_builder)\nluxury_brick_house = director.construct_luxury_house()\nprint(luxury_brick_house)\n</code></pre> <pre><code>package builder\n\nimport \"fmt\"\n\nfunc main() {\n    woodenHouseBuilder := &amp;WoodenHouseBuilder{}\n    brickHouseBuilder := &amp;BrickHouseBuilder{}\n\n    director := Director{builder: woodenHouseBuilder}\n    simpleWoodenHouse := director.ConstructSimpleHouse()\n    fmt.Println(simpleWoodenHouse) // Output: House with foundation: Wooden Foundation, structure: Wooden Structure, roof: Wooden Roof, rooms: 2 Wooden Rooms, backyard:\n\n    director = Director{builder: brickHouseBuilder}\n    luxuryBrickHouse := director.ConstructLuxuryHouse()\n    fmt.Println(luxuryBrickHouse) // Output: House with foundation: Concrete Foundation, structure: Brick Structure, roof: Concrete Roof, rooms: 5 Brick Rooms, backyard: Brick Luxury Backyard\n}\n</code></pre>"},{"location":"design-patterns/creational/factory-method/","title":"Factory Method Pattern","text":""},{"location":"design-patterns/creational/factory-method/#description","title":"Description","text":"<p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don\u2019t worry: the objects are still created via the new operator, but it\u2019s being called from within the factory method. Objects returned by a factory method are often referred to as products.</p>"},{"location":"design-patterns/creational/factory-method/#benefits","title":"Benefits","text":"<ol> <li> <p>Decoupling Object Creation: The Factory Method Pattern separates the process of creating an object from the rest of the code, making the codebase more modular and easier to manage.</p> </li> <li> <p>Single Responsibility Principle: By centralizing the object creation code in one place, the Factory Method Pattern adheres to the Single Responsibility Principle, as the classes do not need to know the details of object creation.</p> </li> <li> <p>Flexibility and Extensibility: This pattern provides flexibility by allowing the creation of objects without specifying the exact class of the object that will be created. It also makes the code more extensible by allowing new classes to be added without modifying existing code.</p> </li> <li> <p>Enhanced Maintainability: By using the Factory Method Pattern, changes in the object creation process affect only the factory code, making the system easier to maintain and update.</p> </li> <li> <p>Code Reusability: The Factory Method Pattern promotes code reuse by enabling the creation of objects through a common interface, which can be used across different parts of the application.</p> </li> </ol>"},{"location":"design-patterns/creational/factory-method/#example","title":"Example","text":"<p>Imagine you are building a notification system that needs to send notifications through different channels such as email, SMS, and push notifications. The type of notification to be sent depends on user preferences, and you want to encapsulate the notification creation logic in a single place.</p> <p>In this example:</p> <ul> <li>The NotificationFactory is the Factory.</li> <li>The Factory Method Pattern ensures that the application creates the appropriate type of notification based on user preferences.</li> <li>This approach simplifies the notification creation process and makes it easier to add new notification types in the future.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#implementation","title":"Implementation","text":"<ul> <li>All notifications have a <code>send()</code> method (business logic), so <code>Notifications</code> is the base class, <code>EmailNotifcation</code> and <code>SMSNotification</code> inherit from the base and must implement their custom business logic.</li> <li>The <code>NotificationFactory</code> is also a base (abstract) class, <code>ConcreateNotificationFactory</code> which can be <code>SMSNotificationFactory</code> or <code>EmailNotificationFactory</code> will implement <code>createNotification() -&gt; Notification</code> separately.</li> <li>So in runtime, depending on which product you want to create, you'd instantiate that factory and create it.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Notification {\n        +send(content: str): void\n    }\n\n    class EmailNotification {\n        +send(content: str): void\n    }\n\n    class SMSNotification {\n        +send(content: str): void\n    }\n\n    class NotificationFactory {\n        Abstract +createNotification(): Notification\n    }\n\n    class ConcreteNotificationFactory {\n        +createNotification(): Notification\n    }\n\n    Notification &lt;|-- EmailNotification\n    Notification &lt;|-- SMSNotification\n    NotificationFactory &lt;|-- ConcreteNotificationFactory\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Notification(ABC):\n    @abstractmethod\n    def send(self, content: str):\n        pass\n\n\nclass EmailNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending email with content: {content}\")\n\n\nclass SMSNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending SMS with content: {content}\")\n\n\nclass NotificationFactory(ABC):\n    @abstractmethod\n    def create_notification() -&gt; Notification:\n        # can add complex shared logic here\n        pass\n\n\nclass EmailNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return EmailNotification()\n\n\nclass SMSNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return SMSNotification()\n</code></pre> <pre><code>package implementation\n\n// uses a gun example (only has one concrete factory &amp; method with product impl using if statement)\nimport \"fmt\"\n\n// iGun.go declare the interface for the gun\ntype IGun interface {\n    SetName(name string)\n    SetPower(power int)\n    GetName() string\n    GetPower() int\n}\n\n// gun.go concrete gun struct\ntype Gun struct {\n    name  string\n    power int\n}\n\nfunc (g *Gun) SetName(name string) {\n    g.name = name\n}\n\nfunc (g *Gun) GetName() string {\n    return g.name\n}\n\nfunc (g *Gun) SetPower(power int) {\n    g.power = power\n}\n\nfunc (g *Gun) GetPower() int {\n    return g.power\n}\n\n// ak47.go declares the struct for the AK47 gun\ntype Ak47 struct {\n    Gun\n}\n\nfunc newAk47() IGun {\n    return &amp;Ak47{\n        Gun: Gun{\n            name:  \"AK47 gun\",\n            power: 4,\n        },\n    }\n}\n\n// musket.go declares the struct for the musket gun\ntype musket struct {\n    Gun\n}\n\nfunc newMusket() IGun {\n    return &amp;musket{\n        Gun: Gun{\n            name:  \"Musket gun\",\n            power: 1,\n        },\n    }\n}\n\n// gunFactory.go declares the factory method to get the gun\nfunc GetGun(gunType string) (IGun, error) {\n    if gunType == \"ak47\" {\n        return newAk47(), nil\n    }\n    if gunType == \"musket\" {\n        return newMusket(), nil\n    }\n    return nil, fmt.Errorf(\"Wrong gun type passed\")\n}\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from factory_method import (\n    Notification,\n    SMSNotification,\n    EmailNotification,\n    SMSNotificationFactory,\n    EmailNotificationFactory,\n)\n\n\nemail_factory = EmailNotificationFactory()\nemail_notification = email_factory.create_notification()\nemail_notification.send(\"Hello via Email!\")\n\nsms_factory = SMSNotificationFactory()\nsms_notification = sms_factory.create_notification()\nsms_notification.send(\"Hello via SMS!\")\n\n# tests\nassert isinstance(email_notification, Notification)\nassert isinstance(email_notification, EmailNotification)\nassert isinstance(sms_notification, Notification)\nassert isinstance(sms_notification, SMSNotification)\n</code></pre> <pre><code>package implementation_test\n\nimport (\n    \"testing\"\n    impl \"tkh/code/design-patterns/creational/factory-method/go/implementation\"\n)\n\nfunc TestGetGun(t *testing.T) {\n    ak47, err := impl.GetGun(\"ak47\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if ak47.GetName() != \"AK47 gun\" {\n        t.Errorf(\"expected AK47 gun, got %s\", ak47.GetName())\n    }\n    if ak47.GetPower() != 4 {\n        t.Errorf(\"expected power 4, got %d\", ak47.GetPower())\n    }\n\n    musket, err := impl.GetGun(\"musket\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if musket.GetName() != \"Musket gun\" {\n        t.Errorf(\"expected Musket gun, got %s\", musket.GetName())\n    }\n    if musket.GetPower() != 1 {\n        t.Errorf(\"expected power 1, got %d\", musket.GetPower())\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/object-pool/","title":"Object Pool Pattern","text":""},{"location":"design-patterns/creational/object-pool/#description","title":"Description","text":"<p>The Object Pool offers a mechanism to reuse objects from a set of initialized objects\u2014called the \"pool\"\u2014instead of allocating and destroying them on demand. For objects that get created and destroyed fast - this pattern optimizes performance. </p>"},{"location":"design-patterns/creational/object-pool/#benefits","title":"Benefits","text":"<ol> <li>Improves Performance: Reduces instantiation cost by recycling objects.</li> <li>Manages Memory Usage: Helps manage the memory footprint by limiting the creation of new objects.</li> </ol>"},{"location":"design-patterns/creational/object-pool/#example","title":"Example","text":"<p>Consider a scenario in a gaming application where bullets are frequently created and destroyed. Using the Object Pool pattern, you can have a pool of bullet objects at game start and recycle these objects throughout the game play.</p> <p>In this example:</p> <ul> <li><code>BulletPool</code> manages a collection of Bullet objects, it is the <code>ReusuablePool</code>.</li> <li><code>Bullet</code> is the <code>Resusable</code> and are acquired when a gun fires and released when they hit a target or move off-screen.</li> </ul>"},{"location":"design-patterns/creational/object-pool/#implementation","title":"Implementation","text":"<ul> <li>The <code>Reusuable Pool</code> should ideally be a Singleton. <ul> <li>As such we have a <code>getInstance</code> method to get the singleton. </li> </ul> </li> <li><code>acquire()</code> acquires a Bullet from the pool.</li> <li><code>release(bullet: Bullet)</code> releases the bullet back to the pool.</li> <li><code>maxBullets</code> is used to limit the number of bullets. </li> </ul>"},{"location":"design-patterns/creational/object-pool/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class BulletPool {\n        -List pool\n        -int maxBullets\n        +acquire() Bullet\n        +release(Bullet)\n        +getInstance() BulletPool\n    }\n\n    class Bullet {\n        +move()\n        +draw()\n    }\n\n    BulletPool --&gt; Bullet: uses\n</code></pre>"},{"location":"design-patterns/creational/object-pool/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Bullet:\n    def init(self):\n        self.position = None\n\n    def move(self):\n        # Move the bullet on the screen\n        pass\n\n    def draw(self):\n        # Draw the bullet on the screen\n        pass\n\n\nclass BulletPool:\n    _instance = None\n    maxBullets = 10  # Setting the maximum bullets allowed in the pool\n\n    @staticmethod\n    def getInstance():\n        if BulletPool._instance is None:\n            BulletPool._instance = BulletPool(BulletPool.maxBullets)\n        return BulletPool._instance\n\n    def __init__(self, size):\n        if BulletPool._instance is not None:\n            raise Exception(\"This class is a singleton!\")\n        else:\n            # Initialize the pool with up to 'size' Bullets, capped by maxBullets\n            self.pool = [Bullet() for _ in range(min(size, BulletPool.maxBullets))]\n\n    def acquire(self):\n        if self.pool:\n            return self.pool.pop()\n        else:\n            return Bullet()  # Optionally, you might want to handle this differently\n\n    def release(self, bullet: Bullet):\n        if len(self.pool) &lt; BulletPool.maxBullets:\n            self.pool.append(bullet)\n        else:\n            # Optionally handle or log when the pool is at capacity and cannot accept more bullets\n            pass\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n//////////////////////////////////// Bullet ////////////////////////////////////\n\ntype Bullet struct {\n    Position int\n    Active   bool\n}\n\nfunc NewBullet() *Bullet {\n    return &amp;Bullet{Position: 0, Active: false}\n}\n\nfunc (b *Bullet) Move() {\n    b.Position += 1 // Simulates the bullet moving forward\n}\n\nfunc (b *Bullet) Draw() {\n    fmt.Printf(\"Drawing bullet at position %d\\n\", b.Position)\n}\n\n//////////////////////////////////// BulletPool ////////////////////////////////////\n\ntype BulletPool struct {\n    pool []*Bullet\n    mu   sync.Mutex\n}\n\nvar instance *BulletPool\nvar once sync.Once\n\n// GetInstance returns the singleton instance of BulletPool\nfunc GetInstance() *BulletPool {\n    once.Do(func() {\n        instance = &amp;BulletPool{\n            pool: make([]*Bullet, 0, 10), // Initialize with capacity of 10\n        }\n    })\n    return instance\n}\n\n// Acquire retrieves a Bullet from the pool or creates a new one if none are available\nfunc (p *BulletPool) Acquire() *Bullet {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    if len(p.pool) &gt; 0 {\n        bullet := p.pool[len(p.pool)-1]\n        p.pool = p.pool[:len(p.pool)-1]\n        bullet.Active = true\n        return bullet\n    }\n    return NewBullet() // Create a new bullet if the pool is empty\n}\n\n// Release adds a Bullet back to the pool if there is capacity\nfunc (p *BulletPool) Release(bullet *Bullet) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    if len(p.pool) &lt; cap(p.pool) {\n        bullet.Active = false\n        bullet.Position = 0 // Reset position\n        p.pool = append(p.pool, bullet)\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/object-pool/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from object_pool import BulletPool\n\nbullet_pool = BulletPool.getInstance()\n\n# Simulate acquiring a bullet to fire\nbullet1 = bullet_pool.acquire()\nprint(f\"Bullet acquired and fired at position {bullet1.position}\")\n\n# Do something with the bullet, e.g., move it in a game loop\nbullet1.position += 10  # Simulating the bullet moving\nprint(f\"Bullet moved to position {bullet1.position}\")\n\n# Now, suppose the bullet hits a target or goes off screen\nbullet_pool.release(bullet1)\nprint(f\"Bullet released back to pool from position {bullet1.position}\")\n\n# Acquire another bullet\nbullet2 = bullet_pool.acquire()\nprint(f\"Bullet acquired and fired at position {bullet2.position}\")\n\n# Move this bullet\nbullet2.position += 5\nprint(f\"Bullet moved to position {bullet2.position}\")\n\n# Release the second bullet\nbullet_pool.release(bullet2)\nprint(f\"Bullet released back to pool from position {bullet2.position}\")\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    pool := GetInstance()\n\n    // Acquire a bullet and simulate firing it\n    bullet := pool.Acquire()\n    bullet.Position = 10 // Set starting position\n    fmt.Printf(\"Bullet fired from position %d\\n\", bullet.Position)\n\n    // Move the bullet and draw it\n    bullet.Move()\n    bullet.Draw()\n\n    // Release the bullet back to the pool\n    pool.Release(bullet)\n    fmt.Println(\"Bullet released and returned to pool\")\n}\n</code></pre>"},{"location":"design-patterns/creational/prototype/","title":"Prototype Pattern","text":""},{"location":"design-patterns/creational/prototype/#description","title":"Description","text":"<p>Prototype is a creational design pattern that lets you copy existing objects without making your code dependent on their classes. Normally, to copy an object, you'd have to create that object and then copy its fields over. But some of those fields may be private, or the class itself may be an interface.</p> <p>The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single <code>clone</code> method.</p> <p><code>clone</code>: creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.</p>"},{"location":"design-patterns/creational/prototype/#benefits","title":"Benefits","text":"<ol> <li>Simplifies object creation: The pattern simplifies the creation of complex objects by cloning a prototype, reducing the complexity associated with creating new instances from scratch.</li> </ol>"},{"location":"design-patterns/creational/prototype/#example","title":"Example","text":"<p>Let's consider a scenario where you have a shape interface with concrete implementations for different types of shapes. You can create clones of these shapes without depending on their specific classes.</p> <p>In this example:</p> <ul> <li>The <code>Shape</code> is the prototype interface. </li> <li><code>Circle</code> and <code>Rectangle</code> are the concrete prototypes. </li> </ul>"},{"location":"design-patterns/creational/prototype/#implementation","title":"Implementation","text":"<ul> <li>The <code>Shape</code> interface has <code>clone()</code>, <code>get_area()</code>, and <code>get_sides()</code></li> <li><code>Circle</code>'s constructor needs only a radius while <code>Rectangle</code> needs width and height</li> <li>Each shape implements clone differently - but call the constructor, passing in its own fields.</li> </ul>"},{"location":"design-patterns/creational/prototype/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Shape {\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n    }\n\n    class Circle {\n        +int radius\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n        +String toString()\n    }\n\n    class Rectangle {\n        +int width\n        +int height\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n        +String toString()\n    }\n\n    Shape &lt;|-- Circle\n    Shape &lt;|-- Rectangle\n</code></pre>"},{"location":"design-patterns/creational/prototype/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nimport math\n\n\n# Prototype interface\nclass Shape(ABC):\n    @abstractmethod\n    def clone(self):\n        pass\n\n    @abstractmethod\n    def get_area(self):\n        pass\n\n    @abstractmethod\n    def get_sides(self):\n        pass\n\n\n# Concrete prototype\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def clone(self):\n        # Create a new instance of Circle and copy all fields\n        new_circle = Circle(self.radius)\n        return new_circle\n\n    def get_area(self):\n        return math.pi * self.radius**2\n\n    def get_sides(self):\n        return 0\n\n    def __str__(self):\n        return f\"Circle with radius {self.radius}\"\n\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def clone(self):\n        # Create a new instance of Rectangle and copy all fields\n        new_rectangle = Rectangle(self.width, self.height)\n        return new_rectangle\n\n    def get_area(self):\n        return self.width * self.height\n\n    def get_sides(self):\n        return 4\n\n    def __str__(self):\n        return f\"Rectangle with width {self.width} and height {self.height}\"\n</code></pre> <pre><code>package prototype\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// Prototype interface\ntype Shape interface {\n    Clone() Shape\n    GetArea() float64\n    GetSides() int\n}\n\n// Concrete prototype\ntype Circle struct {\n    Radius int\n}\n\nfunc (c *Circle) Clone() Shape {\n    // Create a new instance of Circle and copy all fields\n    return &amp;Circle{Radius: c.Radius}\n}\n\nfunc (c *Circle) GetArea() float64 {\n    return math.Pi * float64(c.Radius) * float64(c.Radius)\n}\n\nfunc (c *Circle) GetSides() int {\n    return 0\n}\n\nfunc (c *Circle) String() string {\n    return fmt.Sprintf(\"Circle with radius %d\", c.Radius)\n}\n\ntype Rectangle struct {\n    Width, Height int\n}\n\nfunc (r *Rectangle) Clone() Shape {\n    // Create a new instance of Rectangle and copy all fields\n    return &amp;Rectangle{Width: r.Width, Height: r.Height}\n}\n\nfunc (r *Rectangle) GetArea() float64 {\n    return float64(r.Width * r.Height)\n}\n\nfunc (r *Rectangle) GetSides() int {\n    return 4\n}\n\nfunc (r *Rectangle) String() string {\n    return fmt.Sprintf(\"Rectangle with width %d and height %d\", r.Width, r.Height)\n}\n</code></pre>"},{"location":"design-patterns/creational/prototype/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from prototype import Circle, Rectangle\n\n# Client code\ncircle1 = Circle(5)\ncircle2 = circle1.clone()\nrectangle1 = Rectangle(3, 4)\nrectangle2 = rectangle1.clone()\n\nprint(circle1)  # Output: Circle with radius 5\nprint(circle2)  # Output: Circle with radius 5\nprint(f\"Circle area: {circle1.get_area()}\")  # Output: Circle area: 78.53981633974483\nprint(f\"Circle sides: {circle1.get_sides()}\")  # Output: Circle sides: 0\nprint(rectangle1)  # Output: Rectangle with width 3 and height 4\nprint(rectangle2)  # Output: Rectangle with width 3 and height 4\nprint(f\"Rectangle area: {rectangle1.get_area()}\")  # Output: Rectangle area: 12\nprint(f\"Rectangle sides: {rectangle1.get_sides()}\")  # Output: Rectangle sides: 4\n</code></pre> <pre><code>package prototype\n\nimport \"fmt\"\n\n// Client code\nfunc main() {\n    circle1 := &amp;Circle{Radius: 5}\n    circle2 := circle1.Clone()\n    rectangle1 := &amp;Rectangle{Width: 3, Height: 4}\n    rectangle2 := rectangle1.Clone()\n\n    fmt.Println(circle1)                                       // Output: Circle with radius 5\n    fmt.Println(circle2)                                       // Output: Circle with radius 5\n    fmt.Printf(\"Circle area: %f\\n\", circle1.GetArea())         // Output: Circle area: 78.539816\n    fmt.Printf(\"Circle sides: %d\\n\", circle1.GetSides())       // Output: Circle sides: 0\n    fmt.Println(rectangle1)                                    // Output: Rectangle with width 3 and height 4\n    fmt.Println(rectangle2)                                    // Output: Rectangle with width 3 and height 4\n    fmt.Printf(\"Rectangle area: %f\\n\", rectangle1.GetArea())   // Output: Rectangle area: 12.000000\n    fmt.Printf(\"Rectangle sides: %d\\n\", rectangle1.GetSides()) // Output: Rectangle sides: 4\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/","title":"Singleton Pattern","text":""},{"location":"design-patterns/creational/singleton/#description","title":"Description","text":"<p>The Singleton Pattern ensures a class has only one instance and provides a global point of access to it. This pattern is useful when exactly one object is needed to coordinate actions across the system.</p>"},{"location":"design-patterns/creational/singleton/#benefits","title":"Benefits","text":"<ol> <li> <p>Controlled Access to a Single Instance: The Singleton Pattern ensures that there is precisely one instance of a class, which is particularly useful when managing shared resources like configuration settings or logging.</p> </li> <li> <p>Reduced Namespace Pollution: By providing a single point of access, the Singleton Pattern avoids the proliferation of global variables and reduces the risk of naming conflicts.</p> </li> <li> <p>Lazy Initialization: Singleton can be initialized only when it's needed, rather than when the application starts. This can lead to better resource management.</p> </li> <li> <p>Global Access Point: Singleton provides a global access point to an instance, making it easy to use and access the singleton instance throughout the application.</p> </li> <li> <p>Consistency: Ensures that all components of an application use the same instance, leading to consistent behavior and state across the application.</p> </li> <li> <p>Resource Management: Useful for managing limited resources, such as database connections or thread pools, by ensuring that only one instance is used to manage these resources.</p> </li> </ol>"},{"location":"design-patterns/creational/singleton/#example","title":"Example","text":"<p>Imagine you are building a web application that needs to interact with a database. Creating a new database connection every time a request is made would be inefficient and resource-intensive. Instead, you can use the Singleton Pattern to ensure that only one database connection is created and shared across the entire application.</p> <p>In this example:</p> <ul> <li>The database connection is the Singleton.</li> <li>The Singleton Pattern ensures that the application creates only one database connection and uses it for all database operations.</li> <li>This approach improves performance by reducing the overhead of establishing multiple connections and ensures consistent access to the database.</li> </ul>"},{"location":"design-patterns/creational/singleton/#implementation","title":"Implementation","text":"<ul> <li>The Singleton Class's contructor is normal - does everything a normal contructor would do, except it is <code>private</code>!</li> <li><code>getInstance()</code> static method that returns the instance<ul> <li>if no instance, (acquire thread lock if parallel), call private constructor</li> <li>otherwise return instance</li> </ul> </li> </ul>"},{"location":"design-patterns/creational/singleton/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Singleton {\n        -static instance: Singleton\n        -Singleton()\n        +static getInstance(): Singleton\n    }\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Singleton:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:  # check if the static instance already exists\n            # calls __new__ method of the parent (object) class\n            # basically calling object.__new__(Singleton)\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not hasattr(self, \"initialized\"):\n            self.initialized = True  # Avoid reinitialization\n            self.value = 42\n\n    # Public methods (business logic)\n    def get_value(self):\n        return self.value\n\n    def set_value(self, value):\n        self.value = value\n</code></pre> <pre><code>package implementation\n\nimport (\n    \"sync\"\n)\n\n// lowercase singleton struct so it is not accessible outside the package (not exported)\ntype singleton struct {\n    value int\n}\n\n// declare package level variables\nvar (\n    instance *singleton // Pointer to the singleton instance (initialized to nil)\n    once     sync.Once  // used to ensure the singleton is created only once (even with goroutines) (initialized to zero value of sync.Once)\n)\n\n// GetInstance returns the singleton instance of singleton\nfunc GetInstance() *singleton { // returns a pointer to the singleton instance\n    once.Do(func() {\n        // instance is set to the address of a new singleton instance with value 42\n        // singleton's constructor is private, so it can only be created within the package\n        instance = &amp;singleton{value: 42}\n    })\n    return instance\n}\n\n// GetValue returns the value of the singleton instance\nfunc (s *singleton) GetValue() int {\n    return s.value\n}\n\n// SetValue sets the value of the singleton instance\nfunc (s *singleton) SetValue(value int) {\n    s.value = value\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from singleton_implementation import Singleton\n\n# Example usage\nsingleton1 = Singleton()\nsingleton2 = Singleton()\n\n# Ensure both variables point to the same instance\nassert singleton1 is singleton2\n\n# Ensure the initial value is correct\nassert singleton1.get_value() == singleton2.get_value() == 42\n\n# Set a new value using one instance\nsingleton1.set_value(100)\n\n# Ensure both instances reflect the new value\nassert singleton1.get_value() == singleton2.get_value() == 100\n\nprint(\"Singleton works correctly!\")\n</code></pre> <pre><code>package usage\n\nimport (\n    // Standard library packages\n    \"testing\"\n\n    // External package\n    impl \"tkh/code/design-patterns/creational/singleton/go/implementation\"\n)\n\nfunc TestSingleton(t *testing.T) {\n    singleton1 := impl.GetInstance()\n    singleton2 := impl.GetInstance()\n\n    // Ensure both variables point to the same instance\n    if singleton1 != singleton2 {\n        t.Errorf(\"Expected singleton1 and singleton2 to be the same instance, but they are not\")\n    }\n\n    // Ensure the initial value is correct\n    if singleton1.GetValue() != 42 || singleton2.GetValue() != 42 {\n        t.Errorf(\"Expected initial value to be 42, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // Set a new value using one instance\n    singleton1.SetValue(100)\n\n    // Ensure both instances reflect the new value\n    if singleton1.GetValue() != 100 || singleton2.GetValue() != 100 {\n        t.Errorf(\"Expected value to be updated to 100, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // log that we are done testing\n    t.Log(\"Done testing singleton\")\n}\n</code></pre>"},{"location":"design-patterns/structural/adapter/","title":"Adapter Pattern","text":""},{"location":"design-patterns/structural/adapter/#description","title":"Description","text":"<p>The Adapter pattern is a structural design pattern that allows objects with incompatible objects to work collaborate. It acts as a bridge between two otherwise incompatible interfaces by wrapping itself around an object and presenting a different interface. This is particularly useful when integrating new components into existing systems where interfaces do not match.</p>"},{"location":"design-patterns/structural/adapter/#benefits","title":"Benefits","text":"<ol> <li>Increased Compatibility: Allows two different interfaces to work together without modifying their source code.</li> <li>Reusability: Enables the reuse of existing classes even if their interfaces do not match the required business environment.</li> </ol>"},{"location":"design-patterns/structural/adapter/#example","title":"Example","text":"<p>Imagine you have developed a video player application that initially supports only MP4 files. Over time, you want to expand its capabilities to support additional formats like AVI and MKV without modifying the existing media player code.</p> <p>In this example:</p> <ul> <li><code>MP4Player</code> represents the original system designed to play MP4 files.</li> <li><code>MediaAdapter</code> adapts other types of media interfaces (like AVI and MKV players) to the interface expected by the existing video player application.</li> </ul>"},{"location":"design-patterns/structural/adapter/#implementation","title":"Implementation","text":"<p>Inheritance is not strictly necessary, but it is commonly used to achieve interface compatibility, especially in languages that support it. The pattern can be implemented in two main ways: the class adapter approach using inheritance, and the object adapter approach using composition. Here - we do not use inheritance.</p> <ul> <li><code>VideoPlayer</code> is the <code>Target</code> and the main class that uses the <code>MediaAdapter</code> to play different types of media files.<ul> <li>The <code>Target</code> defines the domain-specific interface that the client uses. This is the interface that the adapter must adapt the adaptee to match. </li> </ul> </li> <li>The <code>AVIPlayer</code> class is an <code>Adaptee</code> and a new system that plays AVI files. (new system) (Adaptee)</li> <li>The <code>MP4Player</code> class is an <code>Adaptee</code> and is the original system that plays MP4 files. (legacy system)</li> <li>The <code>MediaAdapter</code> implements the same interface as the <code>MP4Player</code> but uses different media player implementations to handle various formats. As you can see, this class makes it possible for the <code>VideoPlayer</code> to play different types of media files by providing the necessary conversion. The adapter's <code>play</code> method is responsible for determining the type of media file and delegating the request to the appropriate adaptee.</li> </ul>"},{"location":"design-patterns/structural/adapter/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class VideoPlayer {\n        +play(fileType, fileName)\n    }\n\n    class MP4Player {\n        +playMP4(fileName)\n    }\n\n    class AVIPlayer {\n        +playAVI(fileName)\n    }\n\n    class MediaAdapter {\n        -player Object\n        +play(fileType, fileName)\n    }\n\n    VideoPlayer --&gt; MediaAdapter: uses\n    MediaAdapter --&gt; MP4Player: adapts\n    MediaAdapter --&gt; AVIPlayer: adapts\n</code></pre>"},{"location":"design-patterns/structural/adapter/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class MP4Player:\n    def playMP4(self, fileName):\n        print(f\"Playing MP4 file: {fileName}\")\n\n\nclass AVIPlayer:\n    def playAVI(self, fileName):\n        print(f\"Playing AVI file: {fileName}\")\n\n\nclass MediaAdapter:\n    def __init__(self, fileType):\n        if fileType == \"avi\":\n            self.player = AVIPlayer()\n        else:\n            self.player = None\n\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        elif fileType == \"avi\":\n            self.player.playAVI(fileName)\n\n\nclass VideoPlayer:\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        else:\n            adapter = MediaAdapter(fileType)\n            adapter.play(fileType, fileName)\n</code></pre> <pre><code>package adapter\n\nimport \"fmt\"\n\n// MP4Player is a simple struct to play MP4 files.\ntype MP4Player struct{}\n\n// PlayMP4 is a method to play MP4 files.\nfunc (mp *MP4Player) PlayMP4(fileName string) {\n    fmt.Printf(\"Playing MP4 file: %s\\n\", fileName)\n}\n\n// AVIPlayer is a simple struct to play AVI files.\ntype AVIPlayer struct{}\n\n// PlayAVI is a method to play AVI files.\nfunc (av *AVIPlayer) PlayAVI(fileName string) {\n    fmt.Printf(\"Playing AVI file: %s\\n\", fileName)\n}\n\n// MediaAdapter is an adapter for media players that do not match the required method signature.\ntype MediaAdapter struct {\n    player *AVIPlayer\n}\n\n// NewMediaAdapter creates a new MediaAdapter instance based on the fileType.\nfunc NewMediaAdapter(fileType string) *MediaAdapter {\n    if fileType == \"avi\" {\n        return &amp;MediaAdapter{player: &amp;AVIPlayer{}}\n    }\n    return nil\n}\n\n// Play checks the fileType and plays the file using the appropriate method.\nfunc (ma *MediaAdapter) Play(fileType, fileName string) {\n    if fileType == \"avi\" &amp;&amp; ma.player != nil {\n        ma.player.PlayAVI(fileName)\n    }\n}\n\n// VideoPlayer can play different formats by using the appropriate player or adapter.\ntype VideoPlayer struct{}\n\n// Play determines how to play the media based on the file type.\nfunc (vp *VideoPlayer) Play(fileType, fileName string) {\n    if fileType == \"mp4\" {\n        player := MP4Player{}\n        player.PlayMP4(fileName)\n    } else {\n        adapter := NewMediaAdapter(fileType)\n        if adapter != nil {\n            adapter.Play(fileType, fileName)\n        } else {\n            fmt.Println(\"Unsupported file type\")\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/adapter/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from adapter import VideoPlayer\n\n# Create an instance of VideoPlayer\nvideo_player = VideoPlayer()\n\n# Play an MP4 file\nprint(\"Testing MP4 Playback:\")\nvideo_player.play(\"mp4\", \"sample.mp4\")\n\n# Play an AVI file\nprint(\"\\nTesting AVI Playback:\")\nvideo_player.play(\"avi\", \"example.avi\")\n</code></pre> <pre><code>package adapter\n\nimport \"testing\"\n\nfunc TestVideoPlayer(t *testing.T) {\n    vp := VideoPlayer{}\n    vp.Play(\"mp4\", \"example.mp4\") // Should output: Playing MP4 file: example.mp4\n    vp.Play(\"avi\", \"example.avi\") // Should output: Playing AVI file: example.avi\n}\n</code></pre>"},{"location":"design-patterns/structural/bridge/","title":"Bridge Pattern","text":""},{"location":"design-patterns/structural/bridge/#description","title":"Description","text":"<p>Bridge is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies\u2014abstraction and implementation\u2014which can be developed independently of each other.</p> <p>abstraction - The high level control layer for some entity. This does not do work and simply delegates to the <code>implementation</code> layer. (example: abstraction is UI and implementation is Backend)</p> <p>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app/legacy code to make some otherwise-incompatible classes work together nicely.</p>"},{"location":"design-patterns/structural/bridge/#benefits","title":"Benefits","text":"<ol> <li>Decoupling: Separates the abstraction from the implementation, allowing them to be developed independently.</li> <li>Flexibility: Enables the implementation of the abstraction to change dynamically at runtime.</li> <li>Scalability: Facilitates the addition of new abstractions and implementations without altering existing code.</li> </ol>"},{"location":"design-patterns/structural/bridge/#example","title":"Example","text":"<p>Say, you have two types of computers: Mac and Windows. Also, two types of printers: Epson and HP. Both computers and printers need to work with each other in any combination. The client doesn\u2019t want to worry about the details of connecting printers to computers.</p> <p>If we introduce new printers, we don\u2019t want our code to grow exponentially. Instead of creating four structs for the 2*2 combination, we create two hierarchies:</p> <p>In this example:</p> <ul> <li><code>Abstraction</code>: the computers.</li> <li><code>Implementation</code>: the printers.</li> </ul>"},{"location":"design-patterns/structural/bridge/#implementation","title":"Implementation","text":"<ul> <li>The <code>Abstraction</code> (Conputer) contains a reference to the <code>Implementor</code> (Printer) and delegates all work to it.</li> <li>The <code>Implementor</code> (Device) is an interface that defines the operations that the <code>ConcreteImplementors</code> (HPPrinter and EpsonPrinter) must implement.</li> </ul>"},{"location":"design-patterns/structural/bridge/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Computer {\n        -printer: Printer\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class Printer {\n        +print()\n    }\n\n    class Mac {\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class Windows {\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class HPPrinter {\n        +print()\n    }\n\n    class EpsonPrinter {\n        +print()\n    }\n\n    Computer --&gt; Printer: uses\n    Mac --&gt; Computer: extends\n    Windows --&gt; Computer: extends\n    HPPrinter --&gt; Printer: implements\n    EpsonPrinter --&gt; Printer: implements\n</code></pre>"},{"location":"design-patterns/structural/bridge/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class MP4Player:\n    def playMP4(self, fileName):\n        print(f\"Playing MP4 file: {fileName}\")\n\n\nclass AVIPlayer:\n    def playAVI(self, fileName):\n        print(f\"Playing AVI file: {fileName}\")\n\n\nclass MediaAdapter:\n    def __init__(self, fileType):\n        if fileType == \"avi\":\n            self.player = AVIPlayer()\n        else:\n            self.player = None\n\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        elif fileType == \"avi\":\n            self.player.playAVI(fileName)\n\n\nclass VideoPlayer:\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        else:\n            adapter = MediaAdapter(fileType)\n            adapter.play(fileType, fileName)\n</code></pre> <pre><code>package adapter\n\nimport \"fmt\"\n\n// MP4Player is a simple struct to play MP4 files.\ntype MP4Player struct{}\n\n// PlayMP4 is a method to play MP4 files.\nfunc (mp *MP4Player) PlayMP4(fileName string) {\n    fmt.Printf(\"Playing MP4 file: %s\\n\", fileName)\n}\n\n// AVIPlayer is a simple struct to play AVI files.\ntype AVIPlayer struct{}\n\n// PlayAVI is a method to play AVI files.\nfunc (av *AVIPlayer) PlayAVI(fileName string) {\n    fmt.Printf(\"Playing AVI file: %s\\n\", fileName)\n}\n\n// MediaAdapter is an adapter for media players that do not match the required method signature.\ntype MediaAdapter struct {\n    player *AVIPlayer\n}\n\n// NewMediaAdapter creates a new MediaAdapter instance based on the fileType.\nfunc NewMediaAdapter(fileType string) *MediaAdapter {\n    if fileType == \"avi\" {\n        return &amp;MediaAdapter{player: &amp;AVIPlayer{}}\n    }\n    return nil\n}\n\n// Play checks the fileType and plays the file using the appropriate method.\nfunc (ma *MediaAdapter) Play(fileType, fileName string) {\n    if fileType == \"avi\" &amp;&amp; ma.player != nil {\n        ma.player.PlayAVI(fileName)\n    }\n}\n\n// VideoPlayer can play different formats by using the appropriate player or adapter.\ntype VideoPlayer struct{}\n\n// Play determines how to play the media based on the file type.\nfunc (vp *VideoPlayer) Play(fileType, fileName string) {\n    if fileType == \"mp4\" {\n        player := MP4Player{}\n        player.PlayMP4(fileName)\n    } else {\n        adapter := NewMediaAdapter(fileType)\n        if adapter != nil {\n            adapter.Play(fileType, fileName)\n        } else {\n            fmt.Println(\"Unsupported file type\")\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/bridge/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from adapter import VideoPlayer\n\n# Create an instance of VideoPlayer\nvideo_player = VideoPlayer()\n\n# Play an MP4 file\nprint(\"Testing MP4 Playback:\")\nvideo_player.play(\"mp4\", \"sample.mp4\")\n\n# Play an AVI file\nprint(\"\\nTesting AVI Playback:\")\nvideo_player.play(\"avi\", \"example.avi\")\n</code></pre> <pre><code>package adapter\n\nimport \"testing\"\n\nfunc TestVideoPlayer(t *testing.T) {\n    vp := VideoPlayer{}\n    vp.Play(\"mp4\", \"example.mp4\") // Should output: Playing MP4 file: example.mp4\n    vp.Play(\"avi\", \"example.avi\") // Should output: Playing AVI file: example.avi\n}\n</code></pre>"},{"location":"design-patterns/structural/composite/","title":"Composite Pattern","text":""},{"location":"design-patterns/structural/composite/#description","title":"Description","text":"<p>Composite is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.</p> <p>Great pattern for working with tree structures and using recursion over the structure. </p>"},{"location":"design-patterns/structural/composite/#benefits","title":"Benefits","text":"<ol> <li>Simplifies Client Code: You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.</li> <li>Flexibility: The pattern allows you to create complex structures by composing objects into tree structures. This makes it easy to add new types of objects to the structure without changing the client code.</li> </ol>"},{"location":"design-patterns/structural/composite/#example","title":"Example","text":"<p>On your computer your file system can have files and directories. Let's say you want to calculate the size of all objects in a directory. This memory calculation operation applies to both files and folders</p> <p>In this example:</p> <ul> <li><code>Component</code>: the interface that defines the operations that can be performed on both files and directories.</li> <li><code>Leaf</code>: the class that represents a file.</li> <li><code>Composite</code>: the class that represents a directory and can contain both files and other directories.</li> </ul>"},{"location":"design-patterns/structural/composite/#implementation","title":"Implementation","text":"<ul> <li>The <code>Component</code> interface has a <code>calculateSize</code> method that calculates the size of the object.</li> <li>The <code>Directory</code> class is a <code>Composite</code> that can contain both files and directories. It implements the <code>Component</code> interface and delegates the <code>calculateSize</code> operation to its children.</li> <li>The <code>File</code> class is a <code>Leaf</code> that represents a file. It also implements the <code>Component</code> interface and provides the implementation for the <code>calculateSize</code> method.</li> </ul>"},{"location":"design-patterns/structural/composite/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Component {\n        +calculateSize() int\n    }\n\n    class File {\n        -name: string\n        -size: int\n        +calculateSize() int\n    }\n\n    class Directory {\n        -name: string\n        -children: List~Component~\n        +add(component: Component)\n        +calculateSize() int\n    }\n\n    Component &lt;|-- File: implements\n    Component &lt;|-- Directory: implements\n</code></pre>"},{"location":"design-patterns/structural/composite/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nfrom typing import List\n\n\nclass Component(ABC):\n    @abstractmethod\n    def calculate_size(self) -&gt; int:\n        pass\n\n\nclass File(Component):\n    def __init__(self, name: str, size: int):\n        self.name = name\n        self.size = size\n\n    def calculate_size(self) -&gt; int:\n        return self.size\n\n\nclass Directory(Component):\n    def __init__(self, name: str):\n        self.name = name\n        self.children: List[Component] = []\n\n    def add(self, component: Component):\n        self.children.append(component)\n\n    def calculate_size(self) -&gt; int:\n        total_size = 0\n        for child in self.children:\n            total_size += child.calculate_size()\n        return total_size\n</code></pre> <pre><code>package composite\n\ntype Component interface {\n    calculateSize() int\n}\n\ntype Folder struct {\n    components []Component\n    name       string\n}\n\nfunc (f *Folder) calculateSize() int {\n    size := 0\n    for _, component := range f.components {\n        size += component.calculateSize()\n    }\n    return size\n}\n\nfunc (f *Folder) add(component Component) {\n    f.components = append(f.components, component)\n}\n\ntype File struct {\n    size int\n    name string\n}\n\nfunc (f *File) calculateSize() int {\n    return f.size\n}\n</code></pre>"},{"location":"design-patterns/structural/composite/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from composite import File, Directory\n\nfile1 = File(\"File1.txt\", 100)\nfile2 = File(\"File2.txt\", 150)\n\ndir1 = Directory(\"Dir1\")\ndir2 = Directory(\"Dir2\")\n\n# Adding files to directories\ndir1.add(file1)\ndir1.add(file2)\n\n# Adding directory to another directory\ndir2.add(dir1)\n\n# Calculating sizes\nprint(f\"Size of {file1.name}: {file1.calculate_size()} bytes\")\nprint(f\"Size of {dir1.name}: {dir1.calculate_size()} bytes\")\nprint(f\"Size of {dir2.name}: {dir2.calculate_size()} bytes\")\n\nassert dir1.calculate_size() == 250\nassert dir2.calculate_size() == 250\n</code></pre> <pre><code>package composite\n\nimport \"testing\"\n\nfunc TestCompositePattern(t *testing.T) {\n    file1 := &amp;File{name: \"File1.txt\", size: 100}\n    file2 := &amp;File{name: \"File2.txt\", size: 150}\n\n    dir1 := &amp;Folder{name: \"Dir1\"}\n    dir2 := &amp;Folder{name: \"Dir2\"}\n\n    // Adding files to directories\n    dir1.add(file1)\n    dir1.add(file2)\n\n    // Adding directory to another directory\n    dir2.add(dir1)\n\n    // Asserting sizes\n    if file1.calculateSize() != 100 {\n        t.Errorf(\"Expected size of file1: 100, but got %d\", file1.calculateSize())\n    }\n\n    if file2.calculateSize() != 150 {\n        t.Errorf(\"Expected size of file2: 150, but got %d\", file2.calculateSize())\n    }\n\n    if dir1.calculateSize() != 250 {\n        t.Errorf(\"Expected size of dir1: 250, but got %d\", dir1.calculateSize())\n    }\n\n    if dir2.calculateSize() != 250 {\n        t.Errorf(\"Expected size of dir2: 250, but got %d\", dir2.calculateSize())\n    }\n}\n</code></pre>"}]}