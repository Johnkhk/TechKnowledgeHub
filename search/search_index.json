{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Blog/Documentation","text":"<p>This site showcases various design patterns in multiple programming languages and system design concepts.</p>"},{"location":"design-patterns/design-patterns/","title":"Overview","text":""},{"location":"design-patterns/design-patterns/#creational","title":"Creational","text":"<ul> <li>Singleton</li> <li>Factory Method</li> <li>Abstract Factory</li> <li>Builder</li> <li>Prototype</li> <li>Object Pool</li> </ul>"},{"location":"design-patterns/design-patterns/#structural","title":"Structural","text":"<ul> <li>Adapter</li> <li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Facade</li> <li>Flyweight</li> <li>Proxy</li> </ul>"},{"location":"design-patterns/design-patterns/#behavioral","title":"Behavioral","text":"<ul> <li>Chain of Reponsibility</li> <li>Command</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>State</li> <li>Strategy</li> <li>Template</li> <li>Visitor</li> </ul>"},{"location":"design-patterns/behavioral/chain-of-responsibility/","title":"Chain of Responsibility Pattern","text":""},{"location":"design-patterns/behavioral/chain-of-responsibility/#description","title":"Description","text":"<p>Chain of Responsibility (COR) is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it along the chain.</p> <p>For example, you can add authentication, authorization, validation, caching, in that order, to a request. Each handler can either process the request or pass it to the next handler in the chain. This is bloated and bad.</p> <p>COR transforms behaviors into stand-alond <code>handlers</code> which all implement <code>handle(req)</code>. Each handler has a reference to the next handler in the chain and can pass the <code>req</code> to the next handler. Any handler can also choose to stop the chain.</p> <p>Another implementation of COR is that any handler that can process the request, does so, and ends the chain. So either one handler processes the request or none do. </p> <p>One can provide setters for the reference to insert, remove, skip, reorder handlers dynamically. </p> <p>Can be used with Composite to create a tree of handlers.</p> <p>COR differs from Decorator in that decorators aren't allowed to break the chain/flow. Also COR can execute totally arbitrary logic, while decorators are (generally more) limited to the same interface.</p>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#benefits","title":"Benefits","text":"<ol> <li>Use COR when you have to process requests in multiple ways, but don't know the processing order.</li> <li>Open/Closed Principle: You can introduce new handlers into the app without breaking the existing client code.</li> </ol>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#example","title":"Example","text":"<p>Let's say you have a hospital with departments: <code>Reception</code>, <code>Doctor</code>, <code>MedicalExaminationRoom</code> and <code>Cashier</code>. When a patient comes they go through this order respectively.</p> <p>In this example:</p> <ul> <li>The departments are all <code>handlers</code> that implement the <code>handle(patient)</code> method and <code>setNext(department)</code> method.</li> <li>The <code>Hospital</code> is the client that sends the patient to the first department.</li> </ul>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#implementation","title":"Implementation","text":"<ul> <li><code>Handler</code> is the abstract interface that represents the handler.</li> <li><code>Department</code> is the interface the base handler.</li> <li><code>Reception</code>, <code>Doctor</code>, <code>MedicalExaminationRoom</code>, and <code>Cashier</code> are the classes that represent the handlers.</li> <li><code>Hospital</code> is the class that represents the client.</li> </ul>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Handler {\n        +handle(patient: Patient): void\n        +setNext(department: Department): void\n    }\n\n    class Department {\n        -next: Department\n        +handle(patient: Patient): void\n        +setNext(department: Department): void\n    }\n\n    class Reception {\n        +handle(patient: Patient): void\n    }\n\n    class Doctor {\n        +handle(patient: Patient): void\n    }\n\n    class MedicalExaminationRoom {\n        +handle(patient: Patient): void\n    }\n\n    class Cashier {\n        +handle(patient: Patient): void\n    }\n\n    Handler &lt;|-- Department\n    Department &lt;|-- Reception\n    Department &lt;|-- Doctor\n    Department &lt;|-- MedicalExaminationRoom\n    Department &lt;|-- Cashier\n</code></pre>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Handler(ABC):\n\n    @abstractmethod\n    def handle(self, patient):\n        pass\n\n    @abstractmethod\n    def set_next(self, handler):\n        pass\n\n\nclass Department(Handler):\n\n    def __init__(self):\n        self.next = None\n\n    def set_next(self, handler):\n        self.next = handler\n        return handler\n\n    def handle(self, patient):\n        if self.next:\n            return self.next.handle(patient)\n\n\nclass Reception(Department):\n\n    def handle(self, patient):\n        # Business logic\n        if not patient.get(\"insurance\"):\n            print(\"Ending chain no insurance\")\n            return\n        patient[\"log\"] += \"Reception -&gt; \"\n        super().handle(patient)  # Call the next handler\n\n\nclass Doctor(Department):\n\n    def handle(self, patient):\n        patient[\"log\"] += \"Doctor -&gt; \"\n        super().handle(patient)  # Call the next handler\n\n\nclass MedicalExaminationRoom(Department):\n\n    def handle(self, patient):\n        patient[\"log\"] += \"MedicalExaminationRoom -&gt; \"\n        super().handle(patient)  # Call the next handler\n\n\nclass Cashier(Department):\n\n    def handle(self, patient):\n        if patient.get(\"broke\"):\n            print(\"Ending chain patient is broke\")\n            return\n        patient[\"log\"] += \"Cashier -&gt; \"\n        super().handle(patient)  # Call the next handler\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// Patient struct\ntype Patient struct {\n    Insurance bool\n    Broke     bool\n    Log       string\n}\n\n// Handler interface\ntype Handler interface {\n    Handle(patient *Patient)\n    SetNext(handler Handler) Handler\n}\n\n// Department struct\ntype Department struct {\n    next Handler\n}\n\nfunc (d *Department) SetNext(handler Handler) Handler {\n    d.next = handler\n    return handler\n}\n\nfunc (d *Department) Handle(patient *Patient) {\n    if d.next != nil {\n        d.next.Handle(patient)\n    }\n}\n\n// Reception struct\ntype Reception struct {\n    Department\n}\n\nfunc (r *Reception) Handle(patient *Patient) {\n    if !patient.Insurance {\n        fmt.Println(\"Ending chain - no insurance\")\n        return\n    }\n    patient.Log += \"Reception -&gt; \"\n    r.Department.Handle(patient)\n}\n\n// Doctor struct\ntype Doctor struct {\n    Department\n}\n\nfunc (d *Doctor) Handle(patient *Patient) {\n    patient.Log += \"Doctor -&gt; \"\n    d.Department.Handle(patient)\n}\n\n// MedicalExaminationRoom struct\ntype MedicalExaminationRoom struct {\n    Department\n}\n\nfunc (m *MedicalExaminationRoom) Handle(patient *Patient) {\n    patient.Log += \"MedicalExaminationRoom -&gt; \"\n    m.Department.Handle(patient)\n}\n\n// Cashier struct\ntype Cashier struct {\n    Department\n}\n\nfunc (c *Cashier) Handle(patient *Patient) {\n    if patient.Broke {\n        fmt.Println(\"Ending chain - patient is broke\")\n        return\n    }\n    patient.Log += \"Cashier -&gt; \"\n    c.Department.Handle(patient)\n}\n</code></pre>"},{"location":"design-patterns/behavioral/chain-of-responsibility/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from chain_of_responsibility import Reception, Doctor, MedicalExaminationRoom, Cashier\n\nreception = Reception()\ndoctor = Doctor()\nmedical_examination_room = MedicalExaminationRoom()\ncashier = Cashier()\n\nreception.set_next(doctor).set_next(medical_examination_room).set_next(cashier)\n\npatient = {\"insurance\": True, \"broke\": False, \"log\": \"\"}\nreception.handle(patient)\nassert (\n    patient.get(\"log\") == \"Reception -&gt; Doctor -&gt; MedicalExaminationRoom -&gt; Cashier -&gt; \"\n)\n\npatient2 = {\"insurance\": False, \"broke\": False, \"log\": \"\"}\nreception.handle(patient2)\nprint(patient2.get(\"log\"))\nassert patient2.get(\"log\") == \"\"\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n    // Create the departments\n    reception := &amp;Reception{}\n    doctor := &amp;Doctor{}\n    medicalExaminationRoom := &amp;MedicalExaminationRoom{}\n    cashier := &amp;Cashier{}\n\n    // Set up the chain of responsibility\n    reception.SetNext(doctor).SetNext(medicalExaminationRoom).SetNext(cashier)\n\n    // Create a patient\n    patient := &amp;Patient{\n        Insurance: true,\n        Broke:     false,\n        Log:       \"\",\n    }\n\n    // Handle the patient through the chain of responsibility\n    reception.Handle(patient)\n    fmt.Println(\"Patient Log:\", patient.Log)\n    if patient.Log == \"Reception -&gt; Doctor -&gt; MedicalExaminationRoom -&gt; Cashier -&gt; \" {\n        fmt.Println(\"Test passed for patient 1\")\n    } else {\n        fmt.Println(\"Test failed for patient 1\")\n    }\n\n    // Create another patient without insurance\n    patient2 := &amp;Patient{\n        Insurance: false,\n        Broke:     false,\n        Log:       \"\",\n    }\n\n    // Handle the second patient through the chain of responsibility\n    reception.Handle(patient2)\n    fmt.Println(\"Patient2 Log:\", patient2.Log)\n    if patient2.Log == \"\" {\n        fmt.Println(\"Test passed for patient 2\")\n    } else {\n        fmt.Println(\"Test failed for patient 2\")\n    }\n}\n</code></pre>"},{"location":"design-patterns/behavioral/command/","title":"Command Pattern","text":""},{"location":"design-patterns/behavioral/command/#description","title":"Description","text":"<p>Command is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations.</p> <p>Imagine you are making a Copy Button. You realize that copying needs to be invoked from multiple places like the button, or even hit <code>ctrl + c</code> on the keyboard. Originally, having the CopyButton implement the copy logic was fine. But as you add context menus, shortcuts, and other ways to copy, you have to duplicate the copy logic.</p> <p>The command patterns suggests that GUI objects should not send requests directly. Instead, they should send requests to a command object, which will execute the request. So the GUI just triggers the command, which handles the details.</p> <p>So instead of all the button subclasses like CopyButton, etc, we can have the Button class store a reference to a command object. When the button is clicked, it calls the command object's execute method. So now, we can just implement different command objects for different actions.</p> <p>Handlers in Chain of Responsibility (COR) can be Commands. Or the request itself can be a command.</p> <p>You can use Command along with memento to implement <code>undo</code> since memento can save the state just before the command executes.</p>"},{"location":"design-patterns/behavioral/command/#benefits","title":"Benefits","text":"<ol> <li>Open/Closed Principle: You can introduce new commands into the app without breaking existing client code.</li> <li>Principle of separation of concerns: We can decouple GUI from business logic.</li> </ol>"},{"location":"design-patterns/behavioral/command/#example","title":"Example","text":"<p>Let's say you have a TV. You can turn it on with a button on the remote or the button on the TV. You can also change the volume with both the remote and the buttons on the TV. </p> <p>In this example:</p> <ul> <li><code>Button</code> is the class that represents the sender of the command.</li> <li><code>Command</code> is the command interface.</li> <li><code>TurnOnCommand</code>, <code>TurnOffCommand</code>, <code>VolumeUpCommand</code>, and <code>VolumeDownCommand</code> are the concrete command classes.</li> </ul>"},{"location":"design-patterns/behavioral/command/#implementation","title":"Implementation","text":"<ul> <li><code>Command</code> has an <code>execute()</code> method.</li> <li><code>Button</code> has a <code>Command</code> and onClick() method that calls the <code>execute()</code> method of the <code>Command</code>.</li> </ul>"},{"location":"design-patterns/behavioral/command/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Command {\n        +execute()\n    }\n\n    class TurnOnCommand {\n        +execute()\n    }\n\n    class TurnOffCommand {\n        +execute()\n    }\n\n    class VolumeUpCommand {\n        +execute()\n    }\n\n    class VolumeDownCommand {\n        +execute()\n    }\n\n    class Button {\n        -Command command\n        +Button(Command command)\n        +onClick()\n    }\n\n\n    Command &lt;|-- TurnOnCommand\n    Command &lt;|-- TurnOffCommand\n    Command &lt;|-- VolumeUpCommand\n    Command &lt;|-- VolumeDownCommand\n\n    Button --&gt; Command\n</code></pre>"},{"location":"design-patterns/behavioral/command/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n\n\nclass Button:\n    def __init__(self, command: Command):\n        self.command = command\n\n    def onClick(self):\n        self.command.execute()\n\n\nclass TurnOnCommand(Command):\n    def execute(self):\n        print(\"Turning on TV\")\n\n\nclass TurnOffCommand(Command):\n    def execute(self):\n        print(\"Turning off TV\")\n\n\nclass VolumeUpCommand(Command):\n    def execute(self):\n        print(\"Turning up volume\")\n\n\nclass VolumeDownCommand(Command):\n    def execute(self):\n        print(\"Turning down volume\")\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// Command interface\ntype Command interface {\n    Execute()\n}\n\n// Button struct\ntype Button struct {\n    command Command\n}\n\n// NewButton creates a new Button with a given command\nfunc NewButton(command Command) *Button {\n    return &amp;Button{command: command}\n}\n\n// OnClick calls the execute method of the command\nfunc (b *Button) OnClick() {\n    b.command.Execute()\n}\n\n// TurnOnCommand struct\ntype TurnOnCommand struct{}\n\n// Execute method for TurnOnCommand\nfunc (c *TurnOnCommand) Execute() {\n    fmt.Println(\"Turning on TV\")\n}\n\n// TurnOffCommand struct\ntype TurnOffCommand struct{}\n\n// Execute method for TurnOffCommand\nfunc (c *TurnOffCommand) Execute() {\n    fmt.Println(\"Turning off TV\")\n}\n\n// VolumeUpCommand struct\ntype VolumeUpCommand struct{}\n\n// Execute method for VolumeUpCommand\nfunc (c *VolumeUpCommand) Execute() {\n    fmt.Println(\"Turning up volume\")\n}\n\n// VolumeDownCommand struct\ntype VolumeDownCommand struct{}\n\n// Execute method for VolumeDownCommand\nfunc (c *VolumeDownCommand) Execute() {\n    fmt.Println(\"Turning down volume\")\n}\n</code></pre>"},{"location":"design-patterns/behavioral/command/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from command import (\n    Button,\n    TurnOnCommand,\n    TurnOffCommand,\n    VolumeUpCommand,\n    VolumeDownCommand,\n)\n\nremote_on_button = Button(TurnOnCommand())\nremote_off_button = Button(TurnOffCommand())\nremote_volume_up_button = Button(VolumeUpCommand())\nremote_volume_down_button = Button(VolumeDownCommand())\n\ntv_on_button = Button(TurnOnCommand())\ntv_off_button = Button(TurnOffCommand())\ntv_volume_up_button = Button(VolumeUpCommand())\ntv_volume_down_button = Button(VolumeDownCommand())\n</code></pre> <pre><code>package main\n\nfunc main() {\n    turnOnCommand := &amp;TurnOnCommand{}\n    turnOffCommand := &amp;TurnOffCommand{}\n    volumeUpCommand := &amp;VolumeUpCommand{}\n    volumeDownCommand := &amp;VolumeDownCommand{}\n\n    onButton := NewButton(turnOnCommand)\n    offButton := NewButton(turnOffCommand)\n    volumeUpButton := NewButton(volumeUpCommand)\n    volumeDownButton := NewButton(volumeDownCommand)\n\n    onButton.OnClick()\n    offButton.OnClick()\n    volumeUpButton.OnClick()\n    volumeDownButton.OnClick()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/iterator/","title":"Iterator Pattern","text":""},{"location":"design-patterns/behavioral/iterator/#description","title":"Description","text":"<p>Iterator is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).</p> <p>You can even have a depth first or breadth first traversal iterator.</p> <p>You can use Iterators to traverse Composite objects.</p> <p>You can use Visitor along with Iterator to traverse a collection and apply an operation to each element.</p>"},{"location":"design-patterns/behavioral/iterator/#benefits","title":"Benefits","text":"<ol> <li>Open/Closed Principle: You can implement new types of collections and iterators and pass them to existing code without breaking anything.</li> <li>Single Responsibility Principle: You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.</li> </ol>"},{"location":"design-patterns/behavioral/iterator/#example","title":"Example","text":"<p>Let's say you have a singly linked list. You can traverse it with a <code>ForwardIterator</code> or a <code>BackwardIterator</code>.</p> <p>In this example:</p> <ul> <li><code>LinkedListNode</code> is the \"complex\" collection class.</li> <li><code>Iterator</code> is the iterator interface.</li> <li><code>ForwardIterator</code> and <code>BackwardIterator</code> are the concrete iterator classes.</li> </ul>"},{"location":"design-patterns/behavioral/iterator/#implementation","title":"Implementation","text":"<ul> <li><code>Iterator</code> has a <code>next()</code> method that returns the next element.</li> <li><code>LinkedListNode</code> has a <code>value</code> and <code>next</code> properties.</li> </ul>"},{"location":"design-patterns/behavioral/iterator/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Iterator {\n        &lt;&gt;\n        +Next() int\n    }\n\n    class ListNode {\n        +int Value\n        +ListNode Next\n    }\n\n    class ForwardIterator {\n        +ForwardIterator(ListNode head)\n        +Next() int\n        -current : ListNode\n    }\n\n    class ReverseIterator {\n        +ReverseIterator(ListNode head)\n        +Next() int\n        -stack : List~ListNode~\n    }\n\n    class EvenIterator {\n        +EvenIterator(ListNode head)\n        +Next() int\n        -current : ListNode\n    }\n\n    Iterator &lt;|-- ForwardIterator\n    Iterator &lt;|-- ReverseIterator\n    Iterator &lt;|-- EvenIterator\n\n    ForwardIterator --&gt; ListNode\n    ReverseIterator --&gt; ListNode\n    EvenIterator --&gt; ListNode"},{"location":"design-patterns/behavioral/iterator/#code-implementation","title":"Code Implementation","text":"PythonGo\n\n\n<pre><code>from abc import ABC, abstractmethod\n\n\nclass Iterator(ABC):\n    @abstractmethod\n    def next(self):\n        pass\n\n\nclass ForwardIterator(Iterator):\n    def __init__(self, head):\n        self.current = head\n\n    def next(self):\n        if self.current is None:\n            return None\n        value = self.current.value\n        self.current = self.current.next\n        return value\n\n\nclass BackwardIterator(Iterator):\n    def __init__(self, head):\n        self.stack = []\n        current = head\n        while current is not None:\n            self.stack.append(current)\n            current = current.next\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        return node.value\n\n\nclass LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n</code></pre>\n\n\n<pre><code>package main\n\n// Iterator interface\ntype Iterator interface {\n    Next() *int\n}\n\n// LinkedListNode represents a node in the linked list\ntype LinkedListNode struct {\n    Value int\n    Next  *LinkedListNode\n}\n\n// ForwardIterator struct\ntype ForwardIterator struct {\n    current *LinkedListNode\n}\n\n// NewForwardIterator creates a new ForwardIterator\nfunc NewForwardIterator(head *LinkedListNode) *ForwardIterator {\n    return &amp;ForwardIterator{current: head}\n}\n\n// Next returns the next element in forward order\nfunc (it *ForwardIterator) Next() *int {\n    if it.current == nil {\n        return nil\n    }\n    value := it.current.Value\n    it.current = it.current.Next\n    return &amp;value\n}\n\n// BackwardIterator struct\ntype BackwardIterator struct {\n    stack []*LinkedListNode\n}\n\n// NewBackwardIterator creates a new BackwardIterator\nfunc NewBackwardIterator(head *LinkedListNode) *BackwardIterator {\n    it := &amp;BackwardIterator{stack: []*LinkedListNode{}}\n    for current := head; current != nil; current = current.Next {\n        it.stack = append(it.stack, current)\n    }\n    return it\n}\n\n// Next returns the next element in backward order\nfunc (it *BackwardIterator) Next() *int {\n    if len(it.stack) == 0 {\n        return nil\n    }\n    node := it.stack[len(it.stack)-1]\n    it.stack = it.stack[:len(it.stack)-1]\n    return &amp;node.Value\n}\n</code></pre>"},{"location":"design-patterns/behavioral/iterator/#code-usage","title":"Code Usage","text":"PythonGo\n\n\n<pre><code>from iterator import ForwardIterator, BackwardIterator, LinkedListNode\n\nhead = LinkedListNode(1)\nhead.next = LinkedListNode(2)\nhead.next.next = LinkedListNode(3)\nhead.next.next.next = LinkedListNode(4)\nhead.next.next.next.next = LinkedListNode(5)\n\n# Forward traversal\nforward_iterator = ForwardIterator(head)\nprint(\"Forward traversal: \", end=\"\")\nvalue = forward_iterator.next()\nwhile value is not None:\n    print(value, end=\" \")\n    value = forward_iterator.next()\nprint()\n\n# Backward traversal\nbackward_iterator = BackwardIterator(head)\nprint(\"Backward traversal: \", end=\"\")\nvalue = backward_iterator.next()\nwhile value is not None:\n    print(value, end=\" \")\n    value = backward_iterator.next()\nprint()\n</code></pre>\n\n\n<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create a linked list\n    head := &amp;LinkedListNode{Value: 1}\n    head.Next = &amp;LinkedListNode{Value: 2}\n    head.Next.Next = &amp;LinkedListNode{Value: 3}\n    head.Next.Next.Next = &amp;LinkedListNode{Value: 4}\n    head.Next.Next.Next.Next = &amp;LinkedListNode{Value: 5}\n\n    // Forward traversal\n    forwardIt := NewForwardIterator(head)\n    fmt.Print(\"Forward traversal: \")\n    for value := forwardIt.Next(); value != nil; value = forwardIt.Next() {\n        fmt.Print(*value, \" \")\n    }\n    fmt.Println()\n\n    // Backward traversal\n    backwardIt := NewBackwardIterator(head)\n    fmt.Print(\"Backward traversal: \")\n    for value := backwardIt.Next(); value != nil; value = backwardIt.Next() {\n        fmt.Print(*value, \" \")\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/mediator/","title":"Mediator Pattern","text":""},{"location":"design-patterns/behavioral/mediator/#description","title":"Description","text":"<p>Mediator is a behavioral design pattern that prohibits direct communication between objects and instead forces them to collaborate only via a mediator object.</p> <p>Facade is similar in that it also defines a simplified interface to a subsystem of objects. The subsystem is unaware of the facade, and objects within the subsystem can communicate directly. In contrast, Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</p> <p>You can use Visitor along with Mediator to traverse a collection and apply an operation to each element.</p>"},{"location":"design-patterns/behavioral/mediator/#benefits","title":"Benefits","text":"<ol> <li>Open/Closed Principle: You can introduce new mediators without having to change the actual components.</li> <li>Single Responsibility Principle: You can extract the communications between various components into a single place, making it easier to comprehend and maintain.</li> </ol>"},{"location":"design-patterns/behavioral/mediator/#example","title":"Example","text":"<p>Let's say we have a railway station traffic system. Trains never communicate directly with each other. The <code>stationManager</code> acts as the mediator </p> <p>In this example:</p> <ul> <li><code>Mediator</code> is the mediator interface.</li> <li><code>stationManager</code> is the concrete mediator.</li> <li><code>Train</code> is the interface for the concrete classes.</li> <li><code>passengerTrain</code> and <code>freightTrain</code> are the concrete classes.</li> </ul>"},{"location":"design-patterns/behavioral/mediator/#implementation","title":"Implementation","text":"<ul> <li><code>Train</code> has <code>arrive()</code> and <code>depart()</code> methods.</li> <li><code>stationManager</code> has a <code>trainQueue</code>, <code>canArrive(train)</code>, and <code>notifyAboutDeparture()</code> methods.</li> </ul>"},{"location":"design-patterns/behavioral/mediator/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Mediator {\n        +canArrive(train: Train): bool\n        +notifyAboutDeparture()\n    }\n\n    class StationManager {\n        +trainQueue: List~Train~\n        +canArrive(train: Train): bool\n        +notifyAboutDeparture()\n    }\n\n    class Train {\n        +arrive()\n        +depart()\n    }\n\n    class PassengerTrain {\n        +arrive()\n        +depart()\n    }\n\n    class FreightTrain {\n        +arrive()\n        +depart()\n    }\n\n    Mediator &lt;|-- StationManager\n    Train &lt;|-- PassengerTrain\n    Train &lt;|-- FreightTrain\n    Train --&gt; Mediator : interacts with\n    PassengerTrain --&gt; Mediator : interacts with\n    FreightTrain --&gt; Mediator : interacts with\n</code></pre>"},{"location":"design-patterns/behavioral/mediator/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nfrom typing import List\n\n\nclass Mediator(ABC):\n    @abstractmethod\n    def can_arrive(self, train: \"Train\") -&gt; bool:\n        pass\n\n    @abstractmethod\n    def notify_about_departure(self):\n        pass\n\n\nclass StationManager(Mediator):\n    def __init__(self):\n        self.train_queue: List[Train] = []\n\n    def can_arrive(self, train: \"Train\") -&gt; bool:\n        if not self.train_queue:\n            self.train_queue.append(train)\n            return True\n        else:\n            print(f\"{train.__class__.__name__} is waiting for the platform.\")\n            return False\n\n    def notify_about_departure(self):\n        if self.train_queue:\n            departed_train = self.train_queue.pop(0)\n            print(f\"{departed_train.__class__.__name__} has departed.\")\n        if self.train_queue:\n            next_train = self.train_queue[0]\n            print(f\"{next_train.__class__.__name__} can now arrive.\")\n            next_train.arrive()\n\n\nclass Train(ABC):\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    @abstractmethod\n    def arrive(self):\n        pass\n\n    @abstractmethod\n    def depart(self):\n        pass\n\n\n# Client code is simple, just ask the mediator\nclass PassengerTrain(Train):\n    def arrive(self):\n        if self.mediator.can_arrive(self):\n            print(\"Passenger train arrived.\")\n        else:\n            print(\"Passenger train waiting for arrival.\")\n\n    def depart(self):\n        print(\"Passenger train leaving...\")\n        self.mediator.notify_about_departure()\n\n\nclass FreightTrain(Train):\n    def arrive(self):\n        if self.mediator.can_arrive(self):\n            print(\"Freight train arrived.\")\n        else:\n            print(\"Freight train waiting for arrival.\")\n\n    def depart(self):\n        print(\"Freight train leaving...\")\n        self.mediator.notify_about_departure()\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\n// Mediator interface\ntype Mediator interface {\n    CanArrive(train Train) bool\n    NotifyAboutDeparture()\n}\n\n// Concrete Mediator\ntype StationManager struct {\n    trainQueue []Train\n}\n\nfunc NewStationManager() *StationManager {\n    return &amp;StationManager{}\n}\n\nfunc (s *StationManager) CanArrive(train Train) bool {\n    if len(s.trainQueue) == 0 {\n        s.trainQueue = append(s.trainQueue, train)\n        return true\n    } else {\n        fmt.Printf(\"%T is waiting for the platform.\\n\", train)\n        return false\n    }\n}\n\nfunc (s *StationManager) NotifyAboutDeparture() {\n    if len(s.trainQueue) &gt; 0 {\n        departedTrain := s.trainQueue[0]\n        s.trainQueue = s.trainQueue[1:]\n        fmt.Printf(\"%T has departed.\\n\", departedTrain)\n    }\n    if len(s.trainQueue) &gt; 0 {\n        nextTrain := s.trainQueue[0]\n        fmt.Printf(\"%T can now arrive.\\n\", nextTrain)\n        nextTrain.Arrive()\n    }\n}\n\n// Train interface\ntype Train interface {\n    Arrive()\n    Depart()\n}\n\n// PassengerTrain struct\ntype PassengerTrain struct {\n    mediator Mediator\n}\n\nfunc NewPassengerTrain(mediator Mediator) *PassengerTrain {\n    return &amp;PassengerTrain{mediator: mediator}\n}\n\nfunc (p *PassengerTrain) Arrive() {\n    if p.mediator.CanArrive(p) {\n        fmt.Println(\"Passenger train arrived.\")\n    } else {\n        fmt.Println(\"Passenger train waiting for arrival.\")\n    }\n}\n\nfunc (p *PassengerTrain) Depart() {\n    fmt.Println(\"Passenger train leaving...\")\n    p.mediator.NotifyAboutDeparture()\n}\n\n// FreightTrain struct\ntype FreightTrain struct {\n    mediator Mediator\n}\n\nfunc NewFreightTrain(mediator Mediator) *FreightTrain {\n    return &amp;FreightTrain{mediator: mediator}\n}\n\nfunc (f *FreightTrain) Arrive() {\n    if f.mediator.CanArrive(f) {\n        fmt.Println(\"Freight train arrived.\")\n    } else {\n        fmt.Println(\"Freight train waiting for arrival.\")\n    }\n}\n\nfunc (f *FreightTrain) Depart() {\n    fmt.Println(\"Freight train leaving...\")\n    f.mediator.NotifyAboutDeparture()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/mediator/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from mediator import StationManager, PassengerTrain, FreightTrain\n\nstation_manager = StationManager()\n\npassenger_train = PassengerTrain(station_manager)\nfreight_train = FreightTrain(station_manager)\n\npassenger_train.arrive()\nfreight_train.arrive()\n\npassenger_train.depart()\nfreight_train.arrive()\nfreight_train.depart()\n</code></pre> <pre><code>package main\n\nfunc main() {\n    stationManager := NewStationManager()\n\n    passengerTrain := NewPassengerTrain(stationManager)\n    freightTrain := NewFreightTrain(stationManager)\n\n    passengerTrain.Arrive()\n    freightTrain.Arrive()\n\n    passengerTrain.Depart()\n    freightTrain.Arrive()\n    freightTrain.Depart()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/memento/","title":"Memento Pattern","text":""},{"location":"design-patterns/behavioral/memento/#description","title":"Description","text":"<p>Memento is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation.</p> <p>Let's say you're working on a text editor. You want to implement an undo feature that allows users to revert to the previous state of the text. The Memento pattern can help you achieve this. (Even if the objects you save hide fields in private)</p> <p>The Memento pattern delegates creating the state snapshots to the actual owner of that state, the originator object. Hence, instead of other objects trying to copy the editor\u2019s state from the \u201coutside,\u201d the editor class itself can make the snapshot since it has full access to its own state.</p> <p>The pattern suggests storing the copy of the object\u2019s state in a special object called memento. The contents of the memento aren\u2019t accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot\u2019s metadata (creation time, the name of the performed operation, etc.), but not the original object\u2019s state contained in the snapshot.</p> <p>A caretaker is responsible for keeping a list/stack of mementos, and has access to a limited interface of the memento like storing and retrieving but cannot modify or directly access the state. Caretakers can be Command or Iterator.</p> <p>You can use memento with Command to implement undoable operations. and Iterator to traverse the history of the mementos.</p> <p>Sometimes, Prototype can be a simpler alternative if easy cloning is possible.</p>"},{"location":"design-patterns/behavioral/memento/#benefits","title":"Benefits","text":"<ol> <li>You can produce snapshots of the object\u2019s state without violating its encapsulation.</li> <li>You can simplify the originator\u2019s code by letting the caretaker maintain the history of the originator\u2019s state.</li> </ol>"},{"location":"design-patterns/behavioral/memento/#example","title":"Example","text":"<p>Let's say you're working on a text editor. You want to implement an undo feature that allows users to revert to the previous state of the text. The Memento pattern can help you achieve this.</p> <p>In this example:</p> <ul> <li><code>TextEditor</code> is the originator, and wants to create snapshots of its state.</li> <li><code>TextEditor</code> is also the caretaker, and maintains a list of mementos.</li> <li><code>TextDocument</code> is the document that the <code>TextEditor</code> wants to save and restore.</li> <li><code>Memento</code> encapsulates the state of the <code>TextDocument</code> and can only be created and restored by the <code>TextEditor</code>.</li> </ul>"},{"location":"design-patterns/behavioral/memento/#implementation","title":"Implementation","text":"<ul> <li><code>TextEditor</code> has a <code>TextDocument</code> object to manage the content.</li> <li><code>TextEditor</code> has a history stack to maintain mementos.</li> <li><code>TextEditor</code> has methods <code>write(text: String)</code>, <code>save()</code>, <code>undo()</code>, and <code>getContent()</code>.</li> <li><code>TextDocument</code> has a <code>content</code> property and methods to get and set this content.</li> <li><code>Memento</code> encapsulates the state of <code>TextDocument</code>.</li> </ul>"},{"location":"design-patterns/behavioral/memento/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class TextEditor {\n        -Stack~Memento~ history\n        -TextDocument document\n        +write(text: String)\n        +save()\n        +undo()\n        +getContent(): String\n    }\n\n    class Memento {\n        -String state\n        +Memento(state: String)\n        +getState(): String\n    }\n\n    class TextDocument {\n        -String content\n        +getContent(): String\n        +setContent(content: String)\n    }\n\n    TextEditor --&gt; Memento : creates\n    TextEditor --&gt; Memento : restores from\n    TextEditor --&gt; TextDocument : manages\n    Memento --&gt; TextDocument : stores state\n</code></pre>"},{"location":"design-patterns/behavioral/memento/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class TextDocument:\n    def __init__(self, content=\"\"):\n        self._content = content\n\n    def get_content(self):\n        return self._content\n\n    def set_content(self, content):\n        self._content = content\n\n\nclass Memento:\n    def __init__(self, state):\n        self._state = state\n\n    def get_state(self):\n        return self._state\n\n\nclass TextEditor:\n    def __init__(self, document):\n        self._document = document\n        self._history = []\n\n    def write(self, text):\n        self._document.set_content(self._document.get_content() + text)\n\n    def save(self):\n        self._history.append(Memento(self._document.get_content()))\n\n    def undo(self):\n        if self._history:\n            memento = self._history.pop()\n            self._document.set_content(memento.get_state())\n\n    def get_content(self):\n        return self._document.get_content()\n</code></pre> <pre><code>package main\n\n// TextDocument represents the document being edited\ntype TextDocument struct {\n    content string\n}\n\nfunc (d *TextDocument) GetContent() string {\n    return d.content\n}\n\nfunc (d *TextDocument) SetContent(content string) {\n    d.content = content\n}\n\n// Memento encapsulates the state of the TextDocument\ntype Memento struct {\n    state string\n}\n\nfunc NewMemento(state string) *Memento {\n    return &amp;Memento{state: state}\n}\n\nfunc (m *Memento) GetState() string {\n    return m.state\n}\n\n// TextEditor acts as both the Originator and the Caretaker\ntype TextEditor struct {\n    document *TextDocument\n    history  []*Memento\n}\n\nfunc NewTextEditor(document *TextDocument) *TextEditor {\n    return &amp;TextEditor{\n        document: document,\n        history:  []*Memento{},\n    }\n}\n\nfunc (e *TextEditor) Write(text string) {\n    e.document.SetContent(e.document.GetContent() + text)\n}\n\nfunc (e *TextEditor) Save() {\n    e.history = append(e.history, NewMemento(e.document.GetContent()))\n}\n\nfunc (e *TextEditor) Undo() {\n    if len(e.history) &gt; 0 {\n        memento := e.history[len(e.history)-1]\n        e.history = e.history[:len(e.history)-1]\n        e.document.SetContent(memento.GetState())\n    }\n}\n\nfunc (e *TextEditor) GetContent() string {\n    return e.document.GetContent()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/memento/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from memento import TextDocument, TextEditor\n\n\ndocument = TextDocument(\"\")\neditor = TextEditor(document)\n\neditor.write(\"Hello, \")\neditor.save()  # Save state to memento\neditor.write(\"world!\")\nprint(\"Current State:\", editor.get_content())  # Outputs: Hello, world!\n\neditor.undo()  # Restore previous state from memento\nprint(\"Restored to State:\", editor.get_content())  # Outputs: Hello,\n\neditor.undo()  # Attempt to restore previous state, but history is empty\nprint(\"Restored to State:\", editor.get_content())  # Outputs: Hello, (no change)\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    document := &amp;TextDocument{content: \"\"}\n    editor := NewTextEditor(document)\n\n    editor.Write(\"Hello, \")\n    editor.Save() // Save state to memento\n    editor.Write(\"world!\")\n    fmt.Println(\"Current State:\", editor.GetContent()) // Outputs: Hello, world!\n\n    editor.Undo()                                          // Restore previous state from memento\n    fmt.Println(\"Restored to State:\", editor.GetContent()) // Outputs: Hello,\n\n    editor.Undo()                                          // Attempt to restore previous state, but history is empty\n    fmt.Println(\"Restored to State:\", editor.GetContent()) // Outputs: Hello, (no change)\n}\n</code></pre>"},{"location":"design-patterns/behavioral/observer/","title":"Observer Pattern","text":""},{"location":"design-patterns/behavioral/observer/#description","title":"Description","text":"<p>Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they\u2019re observing.</p> <p>Subscribers (aka observers) can subscribe to a subject, and the Publisher (aka subject) notifies all subscribers when an event occurs.</p> <p>You can use observer with Command to implement undoable operations. and Iterator to traverse the history of the observers.</p> <p>Sometimes, Prototype can be a simpler alternative if easy cloning is possible.</p>"},{"location":"design-patterns/behavioral/observer/#benefits","title":"Benefits","text":"<ol> <li>You can produce snapshots of the object\u2019s state without violating its encapsulation.</li> <li>You can simplify the originator\u2019s code by letting the caretaker maintain the history of the originator\u2019s state.</li> </ol>"},{"location":"design-patterns/behavioral/observer/#example","title":"Example","text":"<p>Let's say a customer visits the store everyday to check a product's availability. That's a waste of time. The store could also send a bunch of emails daily, but that gets very annoying. The Observer pattern can help here:</p> <p>The product's availability is the <code>subject</code>. The store is the <code>publisher</code>, and the customer is the <code>subscriber</code>. The customer can subscribe to the product's availability and get notified when it's available.</p> <p>All subscribers should implement the same interface and the publisher communicates with them only via that interface.</p> <p>In this example:</p> <ul> <li><code>Store</code> is the publisher that notifies subscribers about product availability.</li> <li><code>Customer</code> is the subscriber (observer) that wants to know about product availability.</li> </ul>"},{"location":"design-patterns/behavioral/observer/#implementation","title":"Implementation","text":"<ul> <li><code>Subscriber</code> (Observer) is an interface that all subscribers should implement, it has an <code>update()</code> method, which is called by the <code>Store</code>.</li> <li><code>Customer</code> is a concrete subscriber that implements the <code>Subscriber</code> interface.</li> <li><code>Store</code> (Publisher) has a list of subscribers, a <code>notify()</code> method, and methods to add and remove subscribers.</li> <li>Usually, the <code>notify()</code> method iterates over the list of subscribers and calls their <code>update()</code> method.</li> </ul>"},{"location":"design-patterns/behavioral/observer/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Subscriber {\n        +update()\n    }\n\n    class Customer {\n        -name: String\n        +update()\n    }\n\n    class Store {\n        -subscribers: List~Subscriber~\n        +addSubscriber(subscriber: Subscriber)\n        +removeSubscriber(subscriber: Subscriber)\n        +notify()\n    }\n\n    Store --&gt; Subscriber : manages\n    Customer ..|&gt; Subscriber : implements\n</code></pre>"},{"location":"design-patterns/behavioral/observer/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Subscriber:\n    def update(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\n\n\nclass Customer(Subscriber):\n    def __init__(self, name):\n        self.name = name\n\n    def update(self):\n        print(f\"{self.name} has been notified.\")\n\n\nclass Store:\n    def __init__(self):\n        self.subscribers = []\n\n    def add_subscriber(self, subscriber):\n        self.subscribers.append(subscriber)\n\n    def remove_subscriber(self, subscriber):\n        self.subscribers.remove(subscriber)\n\n    def notify(self):\n        for subscriber in self.subscribers:\n            subscriber.update()\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\n// Subscriber interface that all subscribers must implement\ntype Subscriber interface {\n    Update()\n}\n\n// Customer is a concrete subscriber that implements the Subscriber interface\ntype Customer struct {\n    name string\n}\n\nfunc (c *Customer) Update() {\n    fmt.Printf(\"%s has been notified.\\n\", c.name)\n}\n\n// Store is the publisher that maintains a list of subscribers and notifies them\ntype Store struct {\n    subscribers []Subscriber\n}\n\nfunc (s *Store) addSubscriber(subscriber Subscriber) {\n    s.subscribers = append(s.subscribers, subscriber)\n}\n\nfunc (s *Store) removeSubscriber(subscriber Subscriber) {\n    for i, sub := range s.subscribers {\n        if sub == subscriber {\n            s.subscribers = append(s.subscribers[:i], s.subscribers[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (s *Store) notify() {\n    for _, subscriber := range s.subscribers {\n        subscriber.Update()\n    }\n}\n</code></pre>"},{"location":"design-patterns/behavioral/observer/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from observer import Store, Customer\n\n\nstore = Store()\n\ncustomer1 = Customer(\"Customer 1\")\ncustomer2 = Customer(\"Customer 2\")\n\nstore.add_subscriber(customer1)\nstore.add_subscriber(customer2)\n\nstore.notify()\n# Outputs:\n# Customer 1 has been notified.\n# Customer 2 has been notified.\n\nstore.remove_subscriber(customer1)\n\nstore.notify()\n# Outputs:\n# Customer 2 has been notified.\n</code></pre> <pre><code>package main\n\nfunc main() {\n    store := &amp;Store{}\n\n    customer1 := &amp;Customer{name: \"Customer 1\"}\n    customer2 := &amp;Customer{name: \"Customer 2\"}\n\n    store.addSubscriber(customer1)\n    store.addSubscriber(customer2)\n\n    store.notify()\n    // Outputs:\n    // Customer 1 has been notified.\n    // Customer 2 has been notified.\n\n    store.removeSubscriber(customer1)\n\n    store.notify()\n    // Outputs:\n    // Customer 2 has been notified.\n}\n</code></pre>"},{"location":"design-patterns/behavioral/state/","title":"State Pattern","text":""},{"location":"design-patterns/behavioral/state/#description","title":"Description","text":"<p>State is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class. (Similar to Finite State Machine)</p> <p>There are states and predetermined transitions between them. </p> <p>State machines are usually implemented with lots of conditional statements (if or switch) that select the appropriate behavior depending on the current state of the object. Usually, this \u201cstate\u201d is just a set of values of the object\u2019s fields.</p> <p>The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes.</p> <p>Instead of implementing all behaviors on its own, the original object, called context, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object.</p> <p>To transition the context to another state, replace the active state object with another object that represents that new state. (only if all state classes follow the same interface and the context itself works with these objects through that interface).</p> <p>May look similar to Strategy except states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.</p> <p>Similar to Bridge, State, and Strategy, and to some degree adapter, all these patterns use composition to delegate some work to another object.</p>"},{"location":"design-patterns/behavioral/state/#benefits","title":"Benefits","text":"<ol> <li>Single Responsibility Principle: Organize the code related to particular states into separate classes.</li> <li>Simplify the code of the context by eliminating bulky state machine conditionals.</li> </ol>"},{"location":"design-patterns/behavioral/state/#example","title":"Example","text":"<p>Let's say you have a vending machine with one type of product, and 4 states:</p> <ul> <li><code>hasItem</code> - when the machine has the product.</li> <li><code>noItem</code> - when the machine is out of the product.</li> <li><code>itemRequested</code> - when the user requests the product.</li> <li><code>hasMoney</code> - when the machine has money.</li> </ul> <p>and 4 actions:</p> <ul> <li><code>Add the item</code></li> <li><code>Select the item</code></li> <li><code>Insert money</code></li> <li><code>Dispense item</code></li> </ul> <p>Let\u2019s say vending machine is in itemRequested. Once the \u201cInsert Money\u201d occurs, the machine moves to <code>hasMoney</code>.</p> <p>In this example:</p> <ul> <li><code>VendingMachine</code> is the context that delegates state-specific behaviors to different state objects.</li> <li><code>State</code> is the interface that all concrete states should implement.</li> <li><code>HasItem</code>, <code>NoItem</code>, <code>ItemRequested</code>, and <code>HasMoney</code> are concrete states that implement the <code>State</code> interface.</li> <li><code>addItem()</code>, <code>insertMoney()</code>, <code>selectItem()</code>, and <code>dispenseItem()</code> are actions that the <code>VendingMachine</code> can perform.</li> </ul>"},{"location":"design-patterns/behavioral/state/#implementation","title":"Implementation","text":"<ul> <li><code>VendingMachine</code> has a <code>currentState</code> property that stores a reference to the current state object.</li> <li>For ease of access, <code>VendingMachine</code> also has methods to perform actions like <code>addItem()</code>, <code>insertMoney()</code>, <code>selectItem()</code>, and <code>dispenseItem()</code>, which just calls the same method on the current state object.</li> <li><code>VendorMachine</code> also has a <code>setState()</code> method to change the current state.</li> <li><code>State</code> is an interface that defines a method for each action.</li> <li>Each concrete state also has a reference to the <code>VendingMachine</code> object to change the state of the machine.</li> </ul> <p>The code of the vending machine is not polluted with this logics, all the state-dependent code lives in respective state implementations</p>"},{"location":"design-patterns/behavioral/state/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class VendingMachine {\n        -State hasItem\n        -State noItem\n        -State itemRequested\n        -State hasMoney\n        -State currentState\n        +setState(State state)\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    class State {\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    class HasItem {\n        -VendingMachine vm\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    class NoItem {\n        -VendingMachine vm\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    class ItemRequested {\n        -VendingMachine vm\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    class HasMoney {\n        -VendingMachine vm\n        +addItem()\n        +selectItem()\n        +insertMoney()\n        +dispenseItem()\n    }\n\n    VendingMachine --&gt; State\n    State &lt;|-- HasItem\n    State &lt;|-- NoItem\n    State &lt;|-- ItemRequested\n    State &lt;|-- HasMoney\n</code></pre>"},{"location":"design-patterns/behavioral/state/#state-diagram-of-example","title":"State Diagram Of Example","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; NoItem\n    NoItem --&gt; HasItem : Add item\n    HasItem --&gt; ItemRequested : Select item\n    ItemRequested --&gt; HasMoney : Insert money\n    HasMoney --&gt; NoItem : Dispense item\n    HasItem --&gt; HasItem : Add item\n    ItemRequested --&gt; ItemRequested : Select item\n    ItemRequested --&gt; ItemRequested : Add item\n    HasMoney --&gt; HasMoney : Insert money\n    HasMoney --&gt; HasMoney : Select item\n    NoItem --&gt; NoItem : Select item\n    NoItem --&gt; NoItem : Insert money\n    NoItem --&gt; NoItem : Dispense item\n</code></pre>"},{"location":"design-patterns/behavioral/state/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\n# State Interface\nclass State(ABC):\n    def __init__(self, vendingMachine):\n        self.vendingMachine = vendingMachine\n\n    @abstractmethod\n    def addItem(self):\n        pass\n\n    @abstractmethod\n    def selectItem(self):\n        pass\n\n    @abstractmethod\n    def insertMoney(self):\n        pass\n\n    @abstractmethod\n    def dispenseItem(self):\n        pass\n\n\n# Concrete States\nclass HasItem(State):\n    def addItem(self):\n        print(\"Item already present.\")\n\n    def selectItem(self):\n        print(\"Item selected.\")\n        self.vendingMachine.setState(self.vendingMachine.itemRequestedState)\n\n    def insertMoney(self):\n        print(\"Select an item first.\")\n\n    def dispenseItem(self):\n        print(\"Select an item first.\")\n\n\nclass NoItem(State):\n    def addItem(self):\n        print(\"Item added.\")\n        self.vendingMachine.setState(self.vendingMachine.hasItemState)\n\n    def selectItem(self):\n        print(\"No item to select.\")\n\n    def insertMoney(self):\n        print(\"No item to buy.\")\n\n    def dispenseItem(self):\n        print(\"No item to dispense.\")\n\n\nclass ItemRequested(State):\n    def addItem(self):\n        print(\"Item already requested.\")\n\n    def selectItem(self):\n        print(\"Item already selected.\")\n\n    def insertMoney(self):\n        print(\"Money inserted.\")\n        self.vendingMachine.setState(self.vendingMachine.hasMoneyState)\n\n    def dispenseItem(self):\n        print(\"Insert money first.\")\n\n\nclass HasMoney(State):\n    def addItem(self):\n        print(\"Item already requested.\")\n\n    def selectItem(self):\n        print(\"Item already selected.\")\n\n    def insertMoney(self):\n        print(\"Money already inserted.\")\n\n    def dispenseItem(self):\n        print(\"Dispensing item.\")\n        self.vendingMachine.setState(self.vendingMachine.noItemState)\n\n\n# Vending Machine as a Context and a State\nclass VendingMachine:\n    def __init__(self):\n        self.hasItemState = HasItem(self)\n        self.noItemState = NoItem(self)\n        self.itemRequestedState = ItemRequested(self)\n        self.hasMoneyState = HasMoney(self)\n\n        self.currentState = self.noItemState\n\n    def setState(self, state):\n        self.currentState = state\n\n    def addItem(self):\n        self.currentState.addItem()\n\n    def selectItem(self):\n        self.currentState.selectItem()\n\n    def insertMoney(self):\n        self.currentState.insertMoney()\n\n    def dispenseItem(self):\n        self.currentState.dispenseItem()\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\n// State interface\ntype State interface {\n    AddItem()\n    SelectItem()\n    InsertMoney()\n    DispenseItem()\n}\n\n// VendingMachine struct\ntype VendingMachine struct {\n    hasItemState       State\n    noItemState        State\n    itemRequestedState State\n    hasMoneyState      State\n\n    currentState State\n}\n\nfunc NewVendingMachine() *VendingMachine {\n    v := &amp;VendingMachine{}\n    hasItemState := &amp;HasItemState{vendingMachine: v}\n    noItemState := &amp;NoItemState{vendingMachine: v}\n    itemRequestedState := &amp;ItemRequestedState{vendingMachine: v}\n    hasMoneyState := &amp;HasMoneyState{vendingMachine: v}\n\n    v.hasItemState = hasItemState\n    v.noItemState = noItemState\n    v.itemRequestedState = itemRequestedState\n    v.hasMoneyState = hasMoneyState\n\n    v.currentState = noItemState\n\n    return v\n}\n\nfunc (v *VendingMachine) SetState(state State) {\n    v.currentState = state\n}\n\nfunc (v *VendingMachine) AddItem() {\n    v.currentState.AddItem()\n}\n\nfunc (v *VendingMachine) SelectItem() {\n    v.currentState.SelectItem()\n}\n\nfunc (v *VendingMachine) InsertMoney() {\n    v.currentState.InsertMoney()\n}\n\nfunc (v *VendingMachine) DispenseItem() {\n    v.currentState.DispenseItem()\n}\n\n// Concrete States\ntype HasItemState struct {\n    vendingMachine *VendingMachine\n}\n\nfunc (s *HasItemState) AddItem() {\n    fmt.Println(\"Item already present.\")\n}\n\nfunc (s *HasItemState) SelectItem() {\n    fmt.Println(\"Item selected.\")\n    s.vendingMachine.SetState(s.vendingMachine.itemRequestedState)\n}\n\nfunc (s *HasItemState) InsertMoney() {\n    fmt.Println(\"Select an item first.\")\n}\n\nfunc (s *HasItemState) DispenseItem() {\n    fmt.Println(\"Select an item first.\")\n}\n\ntype NoItemState struct {\n    vendingMachine *VendingMachine\n}\n\nfunc (s *NoItemState) AddItem() {\n    fmt.Println(\"Item added.\")\n    s.vendingMachine.SetState(s.vendingMachine.hasItemState)\n}\n\nfunc (s *NoItemState) SelectItem() {\n    fmt.Println(\"No item to select.\")\n}\n\nfunc (s *NoItemState) InsertMoney() {\n    fmt.Println(\"No item to buy.\")\n}\n\nfunc (s *NoItemState) DispenseItem() {\n    fmt.Println(\"No item to dispense.\")\n}\n\ntype ItemRequestedState struct {\n    vendingMachine *VendingMachine\n}\n\nfunc (s *ItemRequestedState) AddItem() {\n    fmt.Println(\"Item already requested.\")\n}\n\nfunc (s *ItemRequestedState) SelectItem() {\n    fmt.Println(\"Item already selected.\")\n}\n\nfunc (s *ItemRequestedState) InsertMoney() {\n    fmt.Println(\"Money inserted.\")\n    s.vendingMachine.SetState(s.vendingMachine.hasMoneyState)\n}\n\nfunc (s *ItemRequestedState) DispenseItem() {\n    fmt.Println(\"Insert money first.\")\n}\n\ntype HasMoneyState struct {\n    vendingMachine *VendingMachine\n}\n\nfunc (s *HasMoneyState) AddItem() {\n    fmt.Println(\"Item already requested.\")\n}\n\nfunc (s *HasMoneyState) SelectItem() {\n    fmt.Println(\"Item already selected.\")\n}\n\nfunc (s *HasMoneyState) InsertMoney() {\n    fmt.Println(\"Money already inserted.\")\n}\n\nfunc (s *HasMoneyState) DispenseItem() {\n    fmt.Println(\"Dispensing item.\")\n    s.vendingMachine.SetState(s.vendingMachine.noItemState)\n}\n</code></pre>"},{"location":"design-patterns/behavioral/state/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from state import VendingMachine\n\n# Example usage\nvendingMachine = VendingMachine()\n\nvendingMachine.addItem()\nprint(vendingMachine.currentState)\nvendingMachine.selectItem()\nprint(vendingMachine.currentState)\nvendingMachine.insertMoney()\nprint(vendingMachine.currentState)\nvendingMachine.dispenseItem()\nprint(vendingMachine.currentState)\nvendingMachine.addItem()\n</code></pre> <pre><code>package main\n\n// Example usage\nfunc main() {\n    vendingMachine := NewVendingMachine()\n\n    vendingMachine.AddItem()\n    vendingMachine.SelectItem()\n    vendingMachine.InsertMoney()\n    vendingMachine.DispenseItem()\n    vendingMachine.AddItem()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/strategy/","title":"Strategy Pattern","text":""},{"location":"design-patterns/behavioral/strategy/#description","title":"Description","text":"<p>Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.</p> <p>Instead of adding more logic in your main class (which caused merge conflicts in your team), we can extract all of these algorithms into separate classes called strategies.</p> <p>The original class, called context, must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own.</p> <p>The context isn\u2019t responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. (context doesn\u2019t know much about strategies) stragegies expose a single method for triggering the algorithm encapsulated within the selected strategy.</p> <p>Command might seem similar but it converts differnet operations into objects while strategy describes different ways to do the same thing.</p> <p>Decorator lets you change the skin of an object, while Strategy lets you change the guts.</p>"},{"location":"design-patterns/behavioral/strategy/#benefits","title":"Benefits","text":"<ol> <li>You can isolate the implementation details of an algorithm from the code that uses it.</li> <li>You can swap algorithms used inside an object at runtime.</li> </ol>"},{"location":"design-patterns/behavioral/strategy/#example","title":"Example","text":"<p>Let's say you are creating an in-memory-cache. Whenever it reaches its maximum size, some entries have to be evicted to free-up space. You want to implement different strategies for cache eviction. You can have different strategies like:</p> <ul> <li>Least Recently Used (LRU): remove an entry that has been used least recently.</li> <li>First In, First Out (FIFO): remove an entry that was created first.</li> <li>Least Frequently Used (LFU): remove an entry that was least frequently used.</li> </ul> <p>In this example:</p> <ul> <li><code>evictionAlgo</code> is the common interface for all eviction strategies.</li> <li>The main <code>Cache</code> class has a reference to the <code>evictionAlgo</code> interface.</li> </ul>"},{"location":"design-patterns/behavioral/strategy/#implementation","title":"Implementation","text":"<ul> <li><code>LRU</code>, <code>FIFO</code>, and <code>LFU</code> are concrete strategies that implement the <code>evictionAlgo</code> interface.</li> <li><code>evict()</code> is the method that the <code>Cache</code> class calls to evict entries.</li> <li><code>setEvictionAlgo(strategy)</code> is the method that the <code>Cache</code> class uses to change the eviction strategy.</li> <li><code>Cache</code> class has a reference to the current strategy object.</li> </ul>"},{"location":"design-patterns/behavioral/strategy/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Cache {\n        - int maxSize\n        - evictionAlgo strategy\n        + void evict()\n        + void setEvictionAlgo(evictionAlgo strategy)\n        + void add(key, value)\n        + void get(key)\n    }\n\n    class evictionAlgo {\n        + void evict()\n    }\n\n    Cache --&gt; evictionAlgo\n\n    class LRU {\n        + void evict()\n    }\n    evictionAlgo &lt;|-- LRU\n\n    class FIFO {\n        + void evict()\n    }\n    evictionAlgo &lt;|-- FIFO\n\n    class LFU {\n        + void evict()\n    }\n    evictionAlgo &lt;|-- LFU\n</code></pre>"},{"location":"design-patterns/behavioral/strategy/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass EvictionAlgo(ABC):\n    @abstractmethod\n    def evict(self):\n        pass\n\n\nclass LRU(EvictionAlgo):\n    def evict(self):\n        print(\"Evicting using LRU strategy\")\n\n\nclass FIFO(EvictionAlgo):\n    def evict(self):\n        print(\"Evicting using FIFO strategy\")\n\n\nclass LFU(EvictionAlgo):\n    def evict(self):\n        print(\"Evicting using LFU strategy\")\n\n\nclass Cache:\n    def __init__(self, max_size, strategy: EvictionAlgo):\n        self.max_size = max_size\n        self.strategy = strategy\n        self.cache = {}\n\n    def evict(self):\n        self.strategy.evict()\n\n    def set_eviction_algo(self, strategy: EvictionAlgo):\n        self.strategy = strategy\n\n    def add(self, key, value):\n        if len(self.cache) &gt;= self.max_size:\n            self.evict()\n        self.cache[key] = value\n        print(f\"Added {key}: {value} to cache\")\n\n    def get(self, key):\n        return self.cache.get(key, None)\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\n// EvictionAlgo is the interface for all eviction strategies\ntype EvictionAlgo interface {\n    Evict()\n}\n\n// LRU is a concrete strategy that implements EvictionAlgo\ntype LRU struct{}\n\nfunc (l *LRU) Evict() {\n    fmt.Println(\"Evicting using LRU strategy\")\n}\n\n// FIFO is a concrete strategy that implements EvictionAlgo\ntype FIFO struct{}\n\nfunc (f *FIFO) Evict() {\n    fmt.Println(\"Evicting using FIFO strategy\")\n}\n\n// LFU is a concrete strategy that implements EvictionAlgo\ntype LFU struct{}\n\nfunc (l *LFU) Evict() {\n    fmt.Println(\"Evicting using LFU strategy\")\n}\n\n// Cache is the main cache class that uses an eviction strategy\ntype Cache struct {\n    maxSize  int\n    strategy EvictionAlgo\n    cache    map[string]interface{}\n}\n\n// NewCache is a constructor for the Cache\nfunc NewCache(maxSize int, strategy EvictionAlgo) *Cache {\n    return &amp;Cache{\n        maxSize:  maxSize,\n        strategy: strategy,\n        cache:    make(map[string]interface{}),\n    }\n}\n\n// SetEvictionAlgo sets a new eviction strategy\nfunc (c *Cache) SetEvictionAlgo(strategy EvictionAlgo) {\n    c.strategy = strategy\n}\n\n// Evict triggers the eviction strategy\nfunc (c *Cache) Evict() {\n    c.strategy.Evict()\n}\n\n// Add adds a new item to the cache\nfunc (c *Cache) Add(key string, value interface{}) {\n    if len(c.cache) &gt;= c.maxSize {\n        c.Evict()\n    }\n    c.cache[key] = value\n    fmt.Printf(\"Added %s: %v to cache\\n\", key, value)\n}\n\n// Get retrieves an item from the cache\nfunc (c *Cache) Get(key string) interface{} {\n    return c.cache[key]\n}\n</code></pre>"},{"location":"design-patterns/behavioral/strategy/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from cache import Cache, FIFO, LRU\n\ncache = Cache(2, LRU())\ncache.add(\"a\", 1)\ncache.add(\"b\", 2)\ncache.add(\"c\", 3)  # This should trigger eviction\ncache.set_eviction_algo(FIFO())\ncache.add(\"d\", 4)  # This should trigger eviction using FIFO strategy\n</code></pre> <pre><code>package main\n\nfunc main() {\n    lru := &amp;LRU{}\n    fifo := &amp;FIFO{}\n    cache := NewCache(2, lru)\n\n    cache.Add(\"a\", 1)\n    cache.Add(\"b\", 2)\n    cache.Add(\"c\", 3) // This should trigger eviction with LRU\n\n    cache.SetEvictionAlgo(fifo)\n    cache.Add(\"d\", 4) // This should trigger eviction with FIFO\n}\n</code></pre>"},{"location":"design-patterns/behavioral/template-method/","title":"Template Method Pattern","text":""},{"location":"design-patterns/behavioral/template-method/#description","title":"Description","text":"<p>Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.</p> <p>Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. While Strategy is based on composition: you can alter parts of the object's behavior by supplying it with different strategies that correspond to that behavior.</p>"},{"location":"design-patterns/behavioral/template-method/#benefits","title":"Benefits","text":"<ol> <li>You can pull the duplicate code into a superclass.</li> <li>You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.</li> </ol>"},{"location":"design-patterns/behavioral/template-method/#example","title":"Example","text":"<p>Let's say you are creating One Time Password (OTP) functionality. There can be SMS, Email, and Authenticator apps that can generate OTPs.  But irrespective of which one, the entire OTP process is the same:</p> <ol> <li>Generate a random n digit number.</li> <li>Save this number in the cache for later verification.</li> <li>Prepare the content.</li> <li>Send the notification.</li> </ol> <p>In this example:</p> <ul> <li><code>OTP</code> is the abstract class that defines the template method.</li> <li><code>SMSOTP</code>, <code>EmailOTP</code>, and <code>AuthenticatorOTP</code> are concrete classes that implement the <code>OTP</code> class.</li> </ul>"},{"location":"design-patterns/behavioral/template-method/#implementation","title":"Implementation","text":"<ul> <li><code>OTP</code> has a <code>generateOTP()</code>, <code>saveOTP()</code>, <code>prepareContent()</code>, and <code>sendNotification()</code> methods.</li> <li><code>SMSOTP</code>, <code>EmailOTP</code>, and <code>AuthenticatorOTP</code> override the <code>prepareContent()</code> and <code>sendNotification()</code> methods.</li> </ul>"},{"location":"design-patterns/behavioral/template-method/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class OTP {\n        + generateOTP()\n        + saveOTP(otp: string)\n        + prepareContent()\n        + sendNotification()\n        + process()\n    }\n\n    class SMSOTP {\n        + prepareContent()\n        + sendNotification()\n    }\n\n    class EmailOTP {\n        + prepareContent()\n        + sendNotification()\n    }\n\n    class AuthenticatorOTP {\n        + prepareContent()\n        + sendNotification()\n    }\n\n    OTP &lt;|-- SMSOTP\n    OTP &lt;|-- EmailOTP\n    OTP &lt;|-- AuthenticatorOTP\n</code></pre>"},{"location":"design-patterns/behavioral/template-method/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nimport random\n\n\nclass OTP(ABC):\n    def process(self):\n        otp = self.generate_otp()\n        self.save_otp(otp)\n        self.prepare_content()\n        self.send_notification()\n\n    def generate_otp(self, length=6):\n        otp = \"\".join([str(random.randint(0, 9)) for _ in range(length)])\n        print(f\"Generated OTP: {otp}\")\n        return otp\n\n    def save_otp(self, otp):\n        # Simulate saving OTP in cache\n        print(f\"OTP {otp} saved in cache\")\n\n    @abstractmethod\n    def prepare_content(self):\n        pass\n\n    @abstractmethod\n    def send_notification(self):\n        pass\n\n\nclass SMSOTP(OTP):\n    def prepare_content(self):\n        print(\"Preparing SMS content\")\n\n    def send_notification(self):\n        print(\"Sending SMS notification\")\n\n\nclass EmailOTP(OTP):\n    def prepare_content(self):\n        print(\"Preparing Email content\")\n\n    def send_notification(self):\n        print(\"Sending Email notification\")\n\n\nclass AuthenticatorOTP(OTP):\n    def prepare_content(self):\n        print(\"Preparing Authenticator App content\")\n\n    def send_notification(self):\n        print(\"Sending Authenticator App notification\")\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\n// OTP is the abstract base class\ntype OTP interface {\n    Process()\n    generateOTP(length int) string\n    saveOTP(otp string)\n    prepareContent()\n    sendNotification()\n}\n\n// BaseOTP is the base struct that implements the common methods\ntype BaseOTP struct{}\n\n// generateOTP generates a random OTP\nfunc (b *BaseOTP) generateOTP(length int) string {\n    rand.Seed(time.Now().UnixNano())\n    otp := \"\"\n    for i := 0; i &lt; length; i++ {\n        otp += fmt.Sprintf(\"%d\", rand.Intn(10))\n    }\n    fmt.Println(\"Generated OTP:\", otp)\n    return otp\n}\n\n// saveOTP simulates saving the OTP to cache\nfunc (b *BaseOTP) saveOTP(otp string) {\n    fmt.Println(\"OTP\", otp, \"saved in cache\")\n}\n\n// SMSOTP is a concrete class that implements OTP\ntype SMSOTP struct {\n    BaseOTP\n}\n\nfunc (s *SMSOTP) Process() {\n    otp := s.generateOTP(6)\n    s.saveOTP(otp)\n    s.prepareContent()\n    s.sendNotification()\n}\n\nfunc (s *SMSOTP) prepareContent() {\n    fmt.Println(\"Preparing SMS content\")\n}\n\nfunc (s *SMSOTP) sendNotification() {\n    fmt.Println(\"Sending SMS notification\")\n}\n\n// EmailOTP is a concrete class that implements OTP\ntype EmailOTP struct {\n    BaseOTP\n}\n\nfunc (e *EmailOTP) Process() {\n    otp := e.generateOTP(6)\n    e.saveOTP(otp)\n    e.prepareContent()\n    e.sendNotification()\n}\n\nfunc (e *EmailOTP) prepareContent() {\n    fmt.Println(\"Preparing Email content\")\n}\n\nfunc (e *EmailOTP) sendNotification() {\n    fmt.Println(\"Sending Email notification\")\n}\n\n// AuthenticatorOTP is a concrete class that implements OTP\ntype AuthenticatorOTP struct {\n    BaseOTP\n}\n\nfunc (a *AuthenticatorOTP) Process() {\n    otp := a.generateOTP(6)\n    a.saveOTP(otp)\n    a.prepareContent()\n    a.sendNotification()\n}\n\nfunc (a *AuthenticatorOTP) prepareContent() {\n    fmt.Println(\"Preparing Authenticator App content\")\n}\n\nfunc (a *AuthenticatorOTP) sendNotification() {\n    fmt.Println(\"Sending Authenticator App notification\")\n}\n</code></pre>"},{"location":"design-patterns/behavioral/template-method/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from template_method import SMSOTP, EmailOTP, AuthenticatorOTP\n\nsms_otp = SMSOTP()\nsms_otp.process()\n\nemail_otp = EmailOTP()\nemail_otp.process()\n\nauthenticator_otp = AuthenticatorOTP()\nauthenticator_otp.process()\n</code></pre> <pre><code>package main\n\nfunc main() {\n    smsOTP := &amp;SMSOTP{}\n    smsOTP.Process()\n\n    emailOTP := &amp;EmailOTP{}\n    emailOTP.Process()\n\n    authenticatorOTP := &amp;AuthenticatorOTP{}\n    authenticatorOTP.Process()\n}\n</code></pre>"},{"location":"design-patterns/behavioral/visitor/","title":"Visitor Pattern","text":""},{"location":"design-patterns/behavioral/visitor/#description","title":"Description","text":"<p>Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.</p> <p>This pattern is especially useful when dealing with complex object structures, such as composite objects, where you want to perform different operations based on the type of each element.</p> <ol> <li>Elements accept Visitors: each element in the object structure has an <code>accept(visitor)</code> method that accepts a visitor object. It then calls the visitor's appropriate <code>visit(element)</code> method pass, passing itself as an argument.</li> <li>Visitor visits Elements: Visitors implement <code>visit(element)</code> methods for each type of element in the object structure. </li> <li>Double dispatch: The operation that gets executed depends on both the type of the visitor and the type of the element it visits.</li> </ol> <p>You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes. </p> <p>You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.</p>"},{"location":"design-patterns/behavioral/visitor/#benefits","title":"Benefits","text":"<ol> <li>Open/Closed Principle: You can introduce a new behavior that can work with objects of different classes without changing these classes.</li> <li>A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.</li> </ol>"},{"location":"design-patterns/behavioral/visitor/#example","title":"Example","text":"<p>Imagine you have geometric shapes: circles, squares, and triangles. You want to perform several operations on these shapes, such as calculating area, calculating perimeter, and rendering them on the screen.</p> <p>Instead of embedding these operations within the shape classes, you could define these operations in separate visitor classes.</p> <p>In this example:</p> <ul> <li><code>Shape</code> is the interface and <code>Circle</code>, <code>Square</code>, and <code>Triangle</code> are its concrete classes.</li> <li><code>Visitor</code> is the interface that defines the <code>visit_circle(circle)</code>, <code>visit_square(square)</code>, and <code>visit_triangle(triange)</code> methods. (some languages might not support method overloading)</li> <li><code>AreaCalculator</code> and <code>PerimeterCalculator</code> are concrete visitor classes that implement the <code>Visitor</code> interface.</li> </ul>"},{"location":"design-patterns/behavioral/visitor/#implementation","title":"Implementation","text":"<p>So despite the promise of not modifying the shape classes, we still need to modify them to accept visitors. (By adding an <code>accept(visitor)</code> method)</p> <ul> <li><code>Shape</code> has an <code>accept(visitor)</code> method.</li> <li><code>Circle</code>, <code>Square</code>, and <code>Triangle</code> implement the <code>accept(visitor)</code> method. (which calls the appropriate <code>visit</code> method of the visitor)</li> <li>Visitor interface has non-implemented <code>visit_circle(circle)</code>, <code>visit_square(square)</code>, and <code>visit_triangle(triangle)</code> methods.</li> </ul>"},{"location":"design-patterns/behavioral/visitor/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Shape {\n        + accept(visitor: Visitor)\n    }\n\n    class Circle {\n        + accept(visitor: Visitor)\n    }\n\n    class Square {\n        + accept(visitor: Visitor)\n    }\n\n    class Triangle {\n        + accept(visitor: Visitor)\n    }\n\n    Shape &lt;|-- Circle\n    Shape &lt;|-- Square\n    Shape &lt;|-- Triangle\n\n    class Visitor {\n        + visit_circle(circle: Circle)\n        + visit_square(square: Square)\n        + visit_triangle(triangle: Triangle)\n    }\n\n    class AreaCalculator {\n        + visit_circle(circle: Circle)\n        + visit_square(square: Square)\n        + visit_triangle(triangle: Triangle)\n    }\n\n    class PerimeterCalculator {\n        + visit_circle(circle: Circle)\n        + visit_square(square: Square)\n        + visit_triangle(triangle: Triangle)\n    }\n\n    Circle --&gt; Visitor : accept(visitor)\n    Square --&gt; Visitor : accept(visitor)\n    Triangle --&gt; Visitor : accept(visitor)\n\n    Visitor &lt;|-- AreaCalculator\n    Visitor &lt;|-- PerimeterCalculator\n\n</code></pre>"},{"location":"design-patterns/behavioral/visitor/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\n# Visitor interface\nclass Visitor(ABC):\n    @abstractmethod\n    def visit_circle(self, circle):\n        pass\n\n    @abstractmethod\n    def visit_square(self, square):\n        pass\n\n    @abstractmethod\n    def visit_triangle(self, triangle):\n        pass\n\n\n# Concrete Visitor for calculating area\nclass AreaCalculator(Visitor):\n    def visit_circle(self, circle):\n        area = 3.14 * (circle.radius**2)\n        print(f\"Circle area: {area}\")\n\n    def visit_square(self, square):\n        area = square.side * square.side\n        print(f\"Square area: {area}\")\n\n    def visit_triangle(self, triangle):\n        area = 0.5 * triangle.base * triangle.height\n        print(f\"Triangle area: {area}\")\n\n\n# Concrete Visitor for calculating perimeter\nclass PerimeterCalculator(Visitor):\n    def visit_circle(self, circle):\n        perimeter = 2 * 3.14 * circle.radius\n        print(f\"Circle perimeter: {perimeter}\")\n\n    def visit_square(self, square):\n        perimeter = 4 * square.side\n        print(f\"Square perimeter: {perimeter}\")\n\n    def visit_triangle(self, triangle):\n        perimeter = triangle.side_a + triangle.side_b + triangle.side_c\n        print(f\"Triangle perimeter: {perimeter}\")\n\n\n# Shape interface\nclass Shape(ABC):\n    @abstractmethod\n    def accept(self, visitor):\n        pass\n\n\n# Concrete Shape: Circle\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def accept(self, visitor):\n        visitor.visit_circle(self)\n\n\n# Concrete Shape: Square\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def accept(self, visitor):\n        visitor.visit_square(self)\n\n\n# Concrete Shape: Triangle\nclass Triangle(Shape):\n    def __init__(self, side_a, side_b, side_c):\n        self.side_a = side_a\n        self.side_b = side_b\n        self.side_c = side_c\n        self.base = side_a\n        self.height = (\n            side_b**2 - (0.5 * side_a) ** 2\n        ) ** 0.5  # assuming it's an isosceles triangle\n\n    def accept(self, visitor):\n        visitor.visit_triangle(self)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// Visitor interface\ntype Visitor interface {\n    VisitCircle(c *Circle)\n    VisitSquare(s *Square)\n    VisitTriangle(t *Triangle)\n}\n\n// Concrete Visitor for calculating area\ntype AreaCalculator struct{}\n\nfunc (a *AreaCalculator) VisitCircle(c *Circle) {\n    area := math.Pi * c.Radius * c.Radius\n    fmt.Printf(\"Circle area: %.2f\\n\", area)\n}\n\nfunc (a *AreaCalculator) VisitSquare(s *Square) {\n    area := s.Side * s.Side\n    fmt.Printf(\"Square area: %.2f\\n\", area)\n}\n\nfunc (a *AreaCalculator) VisitTriangle(t *Triangle) {\n    area := 0.5 * t.Base * t.Height\n    fmt.Printf(\"Triangle area: %.2f\\n\", area)\n}\n\n// Concrete Visitor for calculating perimeter\ntype PerimeterCalculator struct{}\n\nfunc (p *PerimeterCalculator) VisitCircle(c *Circle) {\n    perimeter := 2 * math.Pi * c.Radius\n    fmt.Printf(\"Circle perimeter: %.2f\\n\", perimeter)\n}\n\nfunc (p *PerimeterCalculator) VisitSquare(s *Square) {\n    perimeter := 4 * s.Side\n    fmt.Printf(\"Square perimeter: %.2f\\n\", perimeter)\n}\n\nfunc (p *PerimeterCalculator) VisitTriangle(t *Triangle) {\n    perimeter := t.SideA + t.SideB + t.SideC\n    fmt.Printf(\"Triangle perimeter: %.2f\\n\", perimeter)\n}\n\n// Shape interface\ntype Shape interface {\n    Accept(visitor Visitor)\n}\n\n// Circle struct\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c *Circle) Accept(visitor Visitor) {\n    visitor.VisitCircle(c)\n}\n\n// Square struct\ntype Square struct {\n    Side float64\n}\n\nfunc (s *Square) Accept(visitor Visitor) {\n    visitor.VisitSquare(s)\n}\n\n// Triangle struct\ntype Triangle struct {\n    SideA  float64\n    SideB  float64\n    SideC  float64\n    Base   float64\n    Height float64\n}\n\nfunc NewTriangle(sideA, sideB, sideC float64) *Triangle {\n    // assuming it's an isosceles triangle for simplicity\n    height := math.Sqrt(sideB*sideB - (0.5*sideA)*(0.5*sideA))\n    return &amp;Triangle{\n        SideA:  sideA,\n        SideB:  sideB,\n        SideC:  sideC,\n        Base:   sideA,\n        Height: height,\n    }\n}\n\nfunc (t *Triangle) Accept(visitor Visitor) {\n    visitor.VisitTriangle(t)\n}\n</code></pre>"},{"location":"design-patterns/behavioral/visitor/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from visitor import Circle, Square, Triangle, AreaCalculator, PerimeterCalculator\n\nshapes = [Circle(10), Square(5), Triangle(6, 8, 8)]\narea_calculator = AreaCalculator()\nperimeter_calculator = PerimeterCalculator()\n\nfor shape in shapes:\n    shape.accept(area_calculator)\n    shape.accept(perimeter_calculator)\n</code></pre> <pre><code>package main\n\nfunc main() {\n    shapes := []Shape{\n        &amp;Circle{Radius: 10},\n        &amp;Square{Side: 5},\n        NewTriangle(6, 8, 8),\n    }\n\n    areaCalculator := &amp;AreaCalculator{}\n    perimeterCalculator := &amp;PerimeterCalculator{}\n\n    for _, shape := range shapes {\n        shape.Accept(areaCalculator)\n        shape.Accept(perimeterCalculator)\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/abstract-factory/","title":"Abstract Factory Pattern","text":""},{"location":"design-patterns/creational/abstract-factory/#description","title":"Description","text":"<p>The abstract factory pattern is for creating families of related objects - (abstract classes). The key difference is that the Factory Method pattern is used to create one type of product, while the Abstract Factory pattern is used to create families of related products. The Abstract Factory pattern uses multiple factory methods to create different products.</p>"},{"location":"design-patterns/creational/abstract-factory/#benefits","title":"Benefits","text":"<ol> <li>Encapsulation of Object Creation: The Abstract Factory pattern encapsulates the creation of related objects in one central place, making the code more modular and easier to manage.</li> </ol>"},{"location":"design-patterns/creational/abstract-factory/#example","title":"Example","text":"<p>Imagine you are developing a user interface toolkit that needs to support multiple themes such as Light and Dark themes. Each theme includes several components like buttons and checkboxes that need to look and behave consistently. By using the Abstract Factory pattern, you can create a family of components for each theme.</p> <p>In this example:</p> <ul> <li>The <code>UIFactory</code> is the Abstract Factory.</li> <li>The <code>LightUIFactory</code> and <code>DarkUIFactory</code> are concrete factories that produce components specific to their themes.</li> <li>Each factory creates a family of products, such as Button and Checkbox, ensuring that all components in a theme are consistent.</li> </ul> <p>note: The factory method example focuses on creating a single type of product (Notification Factory) based on some criteria. - while here in UI Facory, you jave <code>createButton</code> and <code>createCheckbox</code>. Then you can have Light and Dark UI factory as concrete - while in factory method you have <code>createEmail</code> and <code>createSMS</code>...</p>"},{"location":"design-patterns/creational/abstract-factory/#implementation","title":"Implementation","text":"<ul> <li>All UI components implement a common interface, for example, <code>Button</code> and <code>Checkbox</code>.</li> <li>The UIFactory is an abstract class with methods like <code>createButton()</code> and <code>createCheckbox()</code>.</li> <li>Concrete factories like LightUIFactory and DarkUIFactory implement these methods to create theme-specific components.</li> </ul>"},{"location":"design-patterns/creational/abstract-factory/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Button {\n        +render(): void\n    }\n\n    class Checkbox {\n        +render(): void\n    }\n\n    class UIFactory {\n        Abstract +createButton(): Button\n        Abstract +createCheckbox(): Checkbox\n    }\n\n    class LightButton {\n        +render(): void\n    }\n\n    class DarkButton {\n        +render(): void\n    }\n\n    class LightCheckbox {\n        +render(): void\n    }\n\n    class DarkCheckbox {\n        +render(): void\n    }\n\n    class LightUIFactory {\n        +createButton(): Button\n        +createCheckbox(): Checkbox\n    }\n\n    class DarkUIFactory {\n        +createButton(): Button\n        +createCheckbox(): Checkbox\n    }\n\n    Button &lt;|-- LightButton\n    Button &lt;|-- DarkButton\n    Checkbox &lt;|-- LightCheckbox\n    Checkbox &lt;|-- DarkCheckbox\n    UIFactory &lt;|-- LightUIFactory\n    UIFactory &lt;|-- DarkUIFactory\n    LightUIFactory --&gt; LightButton\n    LightUIFactory --&gt; LightCheckbox\n    DarkUIFactory --&gt; DarkButton\n    DarkUIFactory --&gt; DarkCheckbox\n</code></pre>"},{"location":"design-patterns/creational/abstract-factory/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Button(ABC):\n    @abstractmethod\n    def render(self):\n        pass\n\n    @abstractmethod\n    def onClick(self):\n        pass\n\n\nclass Checkbox(ABC):\n    @abstractmethod\n    def render(self):\n        pass\n\n    @abstractmethod\n    def onChange(self):\n        pass\n\n\nclass DarkButton(Button):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering dark button with content: {self.content}\")\n\n    def onClick(self):\n        print(f\"Dark button with content: {self.content} was clicked\")\n\n\nclass DarkCheckbox(Checkbox):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering dark checkbox with content: {self.content}\")\n\n    def onChange(self):\n        print(f\"Dark checkbox with content: {self.content} was changed\")\n\n\nclass LightButton(Button):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering light button with content: {self.content}\")\n\n    def onClick(self):\n        print(f\"Light button with content: {self.content} was clicked\")\n\n\nclass LightCheckbox(Checkbox):\n    def __init__(self, content: str):\n        self.content = content\n\n    def render(self):\n        print(f\"Rendering light checkbox with content: {self.content}\")\n\n    def onChange(self):\n        print(f\"Light checkbox with content: {self.content} was changed\")\n\n\nclass UIFactory(ABC):\n    @abstractmethod\n    def createButton(self, content: str):\n        pass\n\n    @abstractmethod\n    def createCheckbox(self, content: str):\n        pass\n\n\nclass darkUIFactory(UIFactory):\n    def createButton(self, content: str):\n        return DarkButton(content)\n\n    def createCheckbox(self, content: str):\n        return DarkCheckbox(content)\n\n\nclass lightUIFactory(UIFactory):\n    def createButton(self, content: str):\n        return LightButton(content)\n\n    def createCheckbox(self, content: str):\n        return LightCheckbox(content)\n</code></pre> <pre><code>package abstract_factory\n\nimport \"fmt\"\n\n// Button interface\ntype Button interface {\n    Render()\n    OnClick()\n}\n\n// Checkbox interface\ntype Checkbox interface {\n    Render()\n    OnChange()\n}\n\n// DarkButton struct\ntype DarkButton struct {\n    Content string\n}\n\nfunc (b DarkButton) Render() {\n    fmt.Printf(\"Rendering dark button with content: %s\\n\", b.Content)\n}\n\nfunc (b DarkButton) OnClick() {\n    fmt.Printf(\"Dark button with content: %s was clicked\\n\", b.Content)\n}\n\n// DarkCheckbox struct\ntype DarkCheckbox struct {\n    Content string\n}\n\nfunc (c DarkCheckbox) Render() {\n    fmt.Printf(\"Rendering dark checkbox with content: %s\\n\", c.Content)\n}\n\nfunc (c DarkCheckbox) OnChange() {\n    fmt.Printf(\"Dark checkbox with content: %s was changed\\n\", c.Content)\n}\n\n// LightButton struct\ntype LightButton struct {\n    Content string\n}\n\nfunc (b LightButton) Render() {\n    fmt.Printf(\"Rendering light button with content: %s\\n\", b.Content)\n}\n\nfunc (b LightButton) OnClick() {\n    fmt.Printf(\"Light button with content: %s was clicked\\n\", b.Content)\n}\n\n// LightCheckbox struct\ntype LightCheckbox struct {\n    Content string\n}\n\nfunc (c LightCheckbox) Render() {\n    fmt.Printf(\"Rendering light checkbox with content: %s\\n\", c.Content)\n}\n\nfunc (c LightCheckbox) OnChange() {\n    fmt.Printf(\"Light checkbox with content: %s was changed\\n\", c.Content)\n}\n\n// UIFactory interface\ntype UIFactory interface {\n    CreateButton(content string) Button\n    CreateCheckbox(content string) Checkbox\n}\n\n// DarkUIFactory struct\ntype DarkUIFactory struct{}\n\nfunc (f DarkUIFactory) CreateButton(content string) Button {\n    return DarkButton{Content: content}\n}\n\nfunc (f DarkUIFactory) CreateCheckbox(content string) Checkbox {\n    return DarkCheckbox{Content: content}\n}\n\n// LightUIFactory struct\ntype LightUIFactory struct{}\n\nfunc (f LightUIFactory) CreateButton(content string) Button {\n    return LightButton{Content: content}\n}\n\nfunc (f LightUIFactory) CreateCheckbox(content string) Checkbox {\n    return LightCheckbox{Content: content}\n}\n</code></pre>"},{"location":"design-patterns/creational/abstract-factory/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from abstract_factory import darkUIFactory, lightUIFactory\n\n\ndef usage(mode: str):\n    dark_ui_factory = darkUIFactory()\n    light_ui_factory = lightUIFactory()\n\n    if mode == \"dark\":\n        button = dark_ui_factory.createButton(\"Dark button\")\n        checkbox = dark_ui_factory.createCheckbox(\"Dark checkbox\")\n    elif mode == \"light\":\n        button = light_ui_factory.createButton(\"Light button\")\n        checkbox = light_ui_factory.createCheckbox(\"Light checkbox\")\n\n    button.render()\n    button.onClick()\n    checkbox.render()\n    checkbox.onChange()\n</code></pre> <pre><code>package abstract_factory\n\nfunc main() {\n    var factory UIFactory\n\n    // Use the DarkUIFactory\n    factory = DarkUIFactory{}\n    button := factory.CreateButton(\"Dark Mode\")\n    checkbox := factory.CreateCheckbox(\"Dark Mode\")\n    button.Render()\n    button.OnClick()\n    checkbox.Render()\n    checkbox.OnChange()\n\n    // Use the LightUIFactory\n    factory = LightUIFactory{}\n    button = factory.CreateButton(\"Light Mode\")\n    checkbox = factory.CreateCheckbox(\"Light Mode\")\n    button.Render()\n    button.OnClick()\n    checkbox.Render()\n    checkbox.OnChange()\n}\n</code></pre>"},{"location":"design-patterns/creational/builder/","title":"Builder Pattern","text":""},{"location":"design-patterns/creational/builder/#description","title":"Description","text":"<p>Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.</p> <p>Let's say you are building a house - all houses need 4 walls, floor, roof and door. But some houses want a backyard, heating, etc. You don't want to create a million subclasses and you also don't want a big constructor (with a bunch of null calls). </p> <p>Note: Having a director class is also optional, but it can help with organizing construction routines. </p>"},{"location":"design-patterns/creational/builder/#benefits","title":"Benefits","text":"<ol> <li>Controlled Construction Process: The Builder pattern allows you to construct objects step by step, providing more control over the construction process and making it easier to create complex objects.</li> </ol>"},{"location":"design-patterns/creational/builder/#example","title":"Example","text":"<p>Let's say you want to build all types of houses. </p> <p>In this example:</p> <ul> <li>The <code>House</code> is the complex object we want to create.</li> <li>We want to build a wooden house or brick house - each requires a different setup for the foundation. (due to material)</li> <li>We might also want a luxury or basic house. The <code>Director</code> can take care of this.</li> </ul>"},{"location":"design-patterns/creational/builder/#implementation","title":"Implementation","text":"<ul> <li>The complex object <code>House</code> has a default constructor initializing all its fields to <code>None</code>. The fields will include all types of possible houses. </li> <li>The <code>HouseBuilder</code> is our basic builder interface.</li> <li><code>WoodenHouseBuilder</code> and <code>BrickHouseBuilder</code> are our concrete house builders.</li> <li>The <code>Director</code> can <code>construct_simple_house()</code> or <code>construct_luxury_house()</code> or <code>construct_house_with_3_bedrooms()</code>, etc. </li> <li><code>build_backyard(type)</code> can take a type too to mix and match!</li> <li>The steps methods return the builder so we allow for chanining calls. </li> </ul>"},{"location":"design-patterns/creational/builder/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class House {\n        +foundation: str\n        +structure: str\n        +roof: str\n        +rooms: str\n        +backyard: str\n    }\n\n    class HouseBuilder {\n        +build_foundation(): HouseBuilder\n        +build_structure(): HouseBuilder\n        +build_roof(): HouseBuilder\n        +build_rooms(number: int): HouseBuilder\n        +build_backyard(type: str): HouseBuilder\n        +build(): House\n    }\n\n    class WoodenHouseBuilder {\n        +build_foundation(): WoodenHouseBuilder\n        +build_structure(): WoodenHouseBuilder\n        +build_roof(): WoodenHouseBuilder\n        +build_rooms(number: int): WoodenHouseBuilder\n        +build_backyard(type: str): WoodenHouseBuilder\n        +build(): House\n    }\n\n    class BrickHouseBuilder {\n        +build_foundation(): BrickHouseBuilder\n        +build_structure(): BrickHouseBuilder\n        +build_roof(): BrickHouseBuilder\n        +build_rooms(number: int): BrickHouseBuilder\n        +build_backyard(type: str): BrickHouseBuilder\n        +build(): House\n    }\n\n    class Director {\n        +construct_simple_house(): House\n        +construct_luxury_house(): House\n        +construct_house_with_3_bedrooms(): House\n    }\n\n    HouseBuilder &lt;|-- WoodenHouseBuilder\n    HouseBuilder &lt;|-- BrickHouseBuilder\n    Director --&gt; HouseBuilder\n</code></pre>"},{"location":"design-patterns/creational/builder/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass House:\n    def __init__(self):\n        self.foundation = None\n        self.structure = None\n        self.roof = None\n        self.rooms = None\n        self.backyard = None\n\n    def __str__(self):\n        return (\n            f\"House with foundation: {self.foundation}, structure: {self.structure}, \"\n            f\"roof: {self.roof}, rooms: {self.rooms}, backyard: {self.backyard}\"\n        )\n\n\nclass HouseBuilder(ABC):\n    @abstractmethod\n    def build_foundation(self):\n        pass\n\n    @abstractmethod\n    def build_structure(self):\n        pass\n\n    @abstractmethod\n    def build_roof(self):\n        pass\n\n    @abstractmethod\n    def build_rooms(self, number):\n        pass\n\n    @abstractmethod\n    def build_backyard(self, type):\n        pass\n\n    @abstractmethod\n    def build(self):\n        pass\n\n\nclass WoodenHouseBuilder(HouseBuilder):\n    def __init__(self):\n        self.house = House()\n\n    def build_foundation(self):\n        self.house.foundation = \"Wooden Foundation\"\n        return self\n\n    def build_structure(self):\n        self.house.structure = \"Wooden Structure\"\n        return self\n\n    def build_roof(self):\n        self.house.roof = \"Wooden Roof\"\n        return self\n\n    def build_rooms(self, number):\n        self.house.rooms = f\"{number} Wooden Rooms\"\n        return self\n\n    def build_backyard(self, type):\n        self.house.backyard = f\"Wooden {type} Backyard\"\n        return self\n\n    def build(self):\n        return self.house\n\n\nclass BrickHouseBuilder(HouseBuilder):\n    def __init__(self):\n        self.house = House()\n\n    def build_foundation(self):\n        self.house.foundation = \"Concrete Foundation\"\n        return self\n\n    def build_structure(self):\n        self.house.structure = \"Brick Structure\"\n        return self\n\n    def build_roof(self):\n        self.house.roof = \"Concrete Roof\"\n        return self\n\n    def build_rooms(self, number):\n        self.house.rooms = f\"{number} Brick Rooms\"\n        return self\n\n    def build_backyard(self, type):\n        self.house.backyard = f\"Brick {type} Backyard\"\n        return self\n\n    def build(self):\n        return self.house\n\n\nclass Director:\n    def __init__(self, builder):\n        self._builder = builder\n\n    def construct_simple_house(self):\n        self._builder.build_foundation().build_structure().build_roof().build_rooms(2)\n        return self._builder.build()\n\n    def construct_luxury_house(self):\n        self._builder.build_foundation().build_structure().build_roof().build_rooms(\n            5\n        ).build_backyard(\"Luxury\")\n        return self._builder.build()\n</code></pre> <pre><code>package builder\n\nimport (\n    \"fmt\"\n)\n\ntype House struct {\n    Foundation string\n    Structure  string\n    Roof       string\n    Rooms      string\n    Backyard   string\n}\n\nfunc (h House) String() string {\n    return fmt.Sprintf(\"House with foundation: %s, structure: %s, roof: %s, rooms: %s, backyard: %s\",\n        h.Foundation, h.Structure, h.Roof, h.Rooms, h.Backyard)\n}\n\ntype HouseBuilder interface {\n    BuildFoundation() HouseBuilder\n    BuildStructure() HouseBuilder\n    BuildRoof() HouseBuilder\n    BuildRooms(number int) HouseBuilder\n    BuildBackyard(typ string) HouseBuilder\n    Build() House\n}\n\ntype WoodenHouseBuilder struct {\n    house House\n}\n\nfunc (b *WoodenHouseBuilder) BuildFoundation() HouseBuilder {\n    b.house.Foundation = \"Wooden Foundation\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildStructure() HouseBuilder {\n    b.house.Structure = \"Wooden Structure\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildRoof() HouseBuilder {\n    b.house.Roof = \"Wooden Roof\"\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildRooms(number int) HouseBuilder {\n    b.house.Rooms = fmt.Sprintf(\"%d Wooden Rooms\", number)\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) BuildBackyard(typ string) HouseBuilder {\n    b.house.Backyard = fmt.Sprintf(\"Wooden %s Backyard\", typ)\n    return b\n}\n\nfunc (b *WoodenHouseBuilder) Build() House {\n    return b.house\n}\n\ntype BrickHouseBuilder struct {\n    house House\n}\n\nfunc (b *BrickHouseBuilder) BuildFoundation() HouseBuilder {\n    b.house.Foundation = \"Concrete Foundation\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildStructure() HouseBuilder {\n    b.house.Structure = \"Brick Structure\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildRoof() HouseBuilder {\n    b.house.Roof = \"Concrete Roof\"\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildRooms(number int) HouseBuilder {\n    b.house.Rooms = fmt.Sprintf(\"%d Brick Rooms\", number)\n    return b\n}\n\nfunc (b *BrickHouseBuilder) BuildBackyard(typ string) HouseBuilder {\n    b.house.Backyard = fmt.Sprintf(\"Brick %s Backyard\", typ)\n    return b\n}\n\nfunc (b *BrickHouseBuilder) Build() House {\n    return b.house\n}\n\ntype Director struct {\n    builder HouseBuilder\n}\n\nfunc (d *Director) ConstructSimpleHouse() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(2).Build()\n}\n\nfunc (d *Director) ConstructLuxuryHouse() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(5).BuildBackyard(\"Luxury\").Build()\n}\n\nfunc (d *Director) ConstructHouseWith3Bedrooms() House {\n    return d.builder.BuildFoundation().BuildStructure().BuildRoof().BuildRooms(3).BuildBackyard(\"Standard\").Build()\n}\n</code></pre>"},{"location":"design-patterns/creational/builder/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from builder import WoodenHouseBuilder, BrickHouseBuilder, Director\n\n# Client code\nwooden_house_builder = WoodenHouseBuilder()\nbrick_house_builder = BrickHouseBuilder()\n\ndirector = Director(wooden_house_builder)\nsimple_wooden_house = director.construct_simple_house()\nprint(simple_wooden_house)\n\ndirector = Director(brick_house_builder)\nluxury_brick_house = director.construct_luxury_house()\nprint(luxury_brick_house)\n</code></pre> <pre><code>package builder\n\nimport \"fmt\"\n\nfunc main() {\n    woodenHouseBuilder := &amp;WoodenHouseBuilder{}\n    brickHouseBuilder := &amp;BrickHouseBuilder{}\n\n    director := Director{builder: woodenHouseBuilder}\n    simpleWoodenHouse := director.ConstructSimpleHouse()\n    fmt.Println(simpleWoodenHouse) // Output: House with foundation: Wooden Foundation, structure: Wooden Structure, roof: Wooden Roof, rooms: 2 Wooden Rooms, backyard:\n\n    director = Director{builder: brickHouseBuilder}\n    luxuryBrickHouse := director.ConstructLuxuryHouse()\n    fmt.Println(luxuryBrickHouse) // Output: House with foundation: Concrete Foundation, structure: Brick Structure, roof: Concrete Roof, rooms: 5 Brick Rooms, backyard: Brick Luxury Backyard\n}\n</code></pre>"},{"location":"design-patterns/creational/factory-method/","title":"Factory Method Pattern","text":""},{"location":"design-patterns/creational/factory-method/#description","title":"Description","text":"<p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don\u2019t worry: the objects are still created via the new operator, but it\u2019s being called from within the factory method. Objects returned by a factory method are often referred to as products.</p>"},{"location":"design-patterns/creational/factory-method/#benefits","title":"Benefits","text":"<ol> <li> <p>Decoupling Object Creation: The Factory Method Pattern separates the process of creating an object from the rest of the code, making the codebase more modular and easier to manage.</p> </li> <li> <p>Single Responsibility Principle: By centralizing the object creation code in one place, the Factory Method Pattern adheres to the Single Responsibility Principle, as the classes do not need to know the details of object creation.</p> </li> <li> <p>Flexibility and Extensibility: This pattern provides flexibility by allowing the creation of objects without specifying the exact class of the object that will be created. It also makes the code more extensible by allowing new classes to be added without modifying existing code.</p> </li> <li> <p>Enhanced Maintainability: By using the Factory Method Pattern, changes in the object creation process affect only the factory code, making the system easier to maintain and update.</p> </li> <li> <p>Code Reusability: The Factory Method Pattern promotes code reuse by enabling the creation of objects through a common interface, which can be used across different parts of the application.</p> </li> </ol>"},{"location":"design-patterns/creational/factory-method/#example","title":"Example","text":"<p>Imagine you are building a notification system that needs to send notifications through different channels such as email, SMS, and push notifications. The type of notification to be sent depends on user preferences, and you want to encapsulate the notification creation logic in a single place.</p> <p>In this example:</p> <ul> <li>The NotificationFactory is the Factory.</li> <li>The Factory Method Pattern ensures that the application creates the appropriate type of notification based on user preferences.</li> <li>This approach simplifies the notification creation process and makes it easier to add new notification types in the future.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#implementation","title":"Implementation","text":"<ul> <li>All notifications have a <code>send()</code> method (business logic), so <code>Notifications</code> is the base class, <code>EmailNotifcation</code> and <code>SMSNotification</code> inherit from the base and must implement their custom business logic.</li> <li>The <code>NotificationFactory</code> is also a base (abstract) class, <code>ConcreateNotificationFactory</code> which can be <code>SMSNotificationFactory</code> or <code>EmailNotificationFactory</code> will implement <code>createNotification() -&gt; Notification</code> separately.</li> <li>So in runtime, depending on which product you want to create, you'd instantiate that factory and create it.</li> </ul>"},{"location":"design-patterns/creational/factory-method/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Notification {\n        +send(content: str): void\n    }\n\n    class EmailNotification {\n        +send(content: str): void\n    }\n\n    class SMSNotification {\n        +send(content: str): void\n    }\n\n    class NotificationFactory {\n        Abstract +createNotification(): Notification\n    }\n\n    class ConcreteNotificationFactory {\n        +createNotification(): Notification\n    }\n\n    Notification &lt;|-- EmailNotification\n    Notification &lt;|-- SMSNotification\n    NotificationFactory &lt;|-- ConcreteNotificationFactory\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Notification(ABC):\n    @abstractmethod\n    def send(self, content: str):\n        pass\n\n\nclass EmailNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending email with content: {content}\")\n\n\nclass SMSNotification(Notification):\n    def send(self, content: str):\n        print(f\"Sending SMS with content: {content}\")\n\n\nclass NotificationFactory(ABC):\n    @abstractmethod\n    def create_notification() -&gt; Notification:\n        # can add complex shared logic here\n        pass\n\n\nclass EmailNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return EmailNotification()\n\n\nclass SMSNotificationFactory(NotificationFactory):\n    def create_notification(self) -&gt; Notification:\n        # can add complex custom logic here\n        return SMSNotification()\n</code></pre> <pre><code>package implementation\n\n// uses a gun example (only has one concrete factory &amp; method with product impl using if statement)\nimport \"fmt\"\n\n// iGun.go declare the interface for the gun\ntype IGun interface {\n    SetName(name string)\n    SetPower(power int)\n    GetName() string\n    GetPower() int\n}\n\n// gun.go concrete gun struct\ntype Gun struct {\n    name  string\n    power int\n}\n\nfunc (g *Gun) SetName(name string) {\n    g.name = name\n}\n\nfunc (g *Gun) GetName() string {\n    return g.name\n}\n\nfunc (g *Gun) SetPower(power int) {\n    g.power = power\n}\n\nfunc (g *Gun) GetPower() int {\n    return g.power\n}\n\n// ak47.go declares the struct for the AK47 gun\ntype Ak47 struct {\n    Gun\n}\n\nfunc newAk47() IGun {\n    return &amp;Ak47{\n        Gun: Gun{\n            name:  \"AK47 gun\",\n            power: 4,\n        },\n    }\n}\n\n// musket.go declares the struct for the musket gun\ntype musket struct {\n    Gun\n}\n\nfunc newMusket() IGun {\n    return &amp;musket{\n        Gun: Gun{\n            name:  \"Musket gun\",\n            power: 1,\n        },\n    }\n}\n\n// gunFactory.go declares the factory method to get the gun\nfunc GetGun(gunType string) (IGun, error) {\n    if gunType == \"ak47\" {\n        return newAk47(), nil\n    }\n    if gunType == \"musket\" {\n        return newMusket(), nil\n    }\n    return nil, fmt.Errorf(\"Wrong gun type passed\")\n}\n</code></pre>"},{"location":"design-patterns/creational/factory-method/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from factory_method import (\n    Notification,\n    SMSNotification,\n    EmailNotification,\n    SMSNotificationFactory,\n    EmailNotificationFactory,\n)\n\n\nemail_factory = EmailNotificationFactory()\nemail_notification = email_factory.create_notification()\nemail_notification.send(\"Hello via Email!\")\n\nsms_factory = SMSNotificationFactory()\nsms_notification = sms_factory.create_notification()\nsms_notification.send(\"Hello via SMS!\")\n\n# tests\nassert isinstance(email_notification, Notification)\nassert isinstance(email_notification, EmailNotification)\nassert isinstance(sms_notification, Notification)\nassert isinstance(sms_notification, SMSNotification)\n</code></pre> <pre><code>package implementation_test\n\nimport (\n    \"testing\"\n    impl \"tkh/code/design-patterns/creational/factory-method/go/implementation\"\n)\n\nfunc TestGetGun(t *testing.T) {\n    ak47, err := impl.GetGun(\"ak47\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if ak47.GetName() != \"AK47 gun\" {\n        t.Errorf(\"expected AK47 gun, got %s\", ak47.GetName())\n    }\n    if ak47.GetPower() != 4 {\n        t.Errorf(\"expected power 4, got %d\", ak47.GetPower())\n    }\n\n    musket, err := impl.GetGun(\"musket\")\n    if err != nil {\n        t.Errorf(\"expected no error, got %v\", err)\n    }\n    if musket.GetName() != \"Musket gun\" {\n        t.Errorf(\"expected Musket gun, got %s\", musket.GetName())\n    }\n    if musket.GetPower() != 1 {\n        t.Errorf(\"expected power 1, got %d\", musket.GetPower())\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/object-pool/","title":"Object Pool Pattern","text":""},{"location":"design-patterns/creational/object-pool/#description","title":"Description","text":"<p>The Object Pool offers a mechanism to reuse objects from a set of initialized objects\u2014called the \"pool\"\u2014instead of allocating and destroying them on demand. For objects that get created and destroyed fast - this pattern optimizes performance. </p>"},{"location":"design-patterns/creational/object-pool/#benefits","title":"Benefits","text":"<ol> <li>Improves Performance: Reduces instantiation cost by recycling objects.</li> <li>Manages Memory Usage: Helps manage the memory footprint by limiting the creation of new objects.</li> </ol>"},{"location":"design-patterns/creational/object-pool/#example","title":"Example","text":"<p>Consider a scenario in a gaming application where bullets are frequently created and destroyed. Using the Object Pool pattern, you can have a pool of bullet objects at game start and recycle these objects throughout the game play.</p> <p>In this example:</p> <ul> <li><code>BulletPool</code> manages a collection of Bullet objects, it is the <code>ReusuablePool</code>.</li> <li><code>Bullet</code> is the <code>Resusable</code> and are acquired when a gun fires and released when they hit a target or move off-screen.</li> </ul>"},{"location":"design-patterns/creational/object-pool/#implementation","title":"Implementation","text":"<ul> <li>The <code>Reusuable Pool</code> should ideally be a Singleton. <ul> <li>As such we have a <code>getInstance</code> method to get the singleton. </li> </ul> </li> <li><code>acquire()</code> acquires a Bullet from the pool.</li> <li><code>release(bullet: Bullet)</code> releases the bullet back to the pool.</li> <li><code>maxBullets</code> is used to limit the number of bullets. </li> </ul>"},{"location":"design-patterns/creational/object-pool/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class BulletPool {\n        -List pool\n        -int maxBullets\n        +acquire() Bullet\n        +release(Bullet)\n        +getInstance() BulletPool\n    }\n\n    class Bullet {\n        +move()\n        +draw()\n    }\n\n    BulletPool --&gt; Bullet: uses\n</code></pre>"},{"location":"design-patterns/creational/object-pool/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Bullet:\n    def init(self):\n        self.position = None\n\n    def move(self):\n        # Move the bullet on the screen\n        pass\n\n    def draw(self):\n        # Draw the bullet on the screen\n        pass\n\n\nclass BulletPool:\n    _instance = None\n    maxBullets = 10  # Setting the maximum bullets allowed in the pool\n\n    @staticmethod\n    def getInstance():\n        if BulletPool._instance is None:\n            BulletPool._instance = BulletPool(BulletPool.maxBullets)\n        return BulletPool._instance\n\n    def __init__(self, size):\n        if BulletPool._instance is not None:\n            raise Exception(\"This class is a singleton!\")\n        else:\n            # Initialize the pool with up to 'size' Bullets, capped by maxBullets\n            self.pool = [Bullet() for _ in range(min(size, BulletPool.maxBullets))]\n\n    def acquire(self):\n        if self.pool:\n            return self.pool.pop()\n        else:\n            return Bullet()  # Optionally, you might want to handle this differently\n\n    def release(self, bullet: Bullet):\n        if len(self.pool) &lt; BulletPool.maxBullets:\n            self.pool.append(bullet)\n        else:\n            # Optionally handle or log when the pool is at capacity and cannot accept more bullets\n            pass\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n//////////////////////////////////// Bullet ////////////////////////////////////\n\ntype Bullet struct {\n    Position int\n    Active   bool\n}\n\nfunc NewBullet() *Bullet {\n    return &amp;Bullet{Position: 0, Active: false}\n}\n\nfunc (b *Bullet) Move() {\n    b.Position += 1 // Simulates the bullet moving forward\n}\n\nfunc (b *Bullet) Draw() {\n    fmt.Printf(\"Drawing bullet at position %d\\n\", b.Position)\n}\n\n//////////////////////////////////// BulletPool ////////////////////////////////////\n\ntype BulletPool struct {\n    pool []*Bullet\n    mu   sync.Mutex\n}\n\nvar instance *BulletPool\nvar once sync.Once\n\n// GetInstance returns the singleton instance of BulletPool\nfunc GetInstance() *BulletPool {\n    once.Do(func() {\n        instance = &amp;BulletPool{\n            pool: make([]*Bullet, 0, 10), // Initialize with capacity of 10\n        }\n    })\n    return instance\n}\n\n// Acquire retrieves a Bullet from the pool or creates a new one if none are available\nfunc (p *BulletPool) Acquire() *Bullet {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    if len(p.pool) &gt; 0 {\n        bullet := p.pool[len(p.pool)-1]\n        p.pool = p.pool[:len(p.pool)-1]\n        bullet.Active = true\n        return bullet\n    }\n    return NewBullet() // Create a new bullet if the pool is empty\n}\n\n// Release adds a Bullet back to the pool if there is capacity\nfunc (p *BulletPool) Release(bullet *Bullet) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    if len(p.pool) &lt; cap(p.pool) {\n        bullet.Active = false\n        bullet.Position = 0 // Reset position\n        p.pool = append(p.pool, bullet)\n    }\n}\n</code></pre>"},{"location":"design-patterns/creational/object-pool/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from object_pool import BulletPool\n\nbullet_pool = BulletPool.getInstance()\n\n# Simulate acquiring a bullet to fire\nbullet1 = bullet_pool.acquire()\nprint(f\"Bullet acquired and fired at position {bullet1.position}\")\n\n# Do something with the bullet, e.g., move it in a game loop\nbullet1.position += 10  # Simulating the bullet moving\nprint(f\"Bullet moved to position {bullet1.position}\")\n\n# Now, suppose the bullet hits a target or goes off screen\nbullet_pool.release(bullet1)\nprint(f\"Bullet released back to pool from position {bullet1.position}\")\n\n# Acquire another bullet\nbullet2 = bullet_pool.acquire()\nprint(f\"Bullet acquired and fired at position {bullet2.position}\")\n\n# Move this bullet\nbullet2.position += 5\nprint(f\"Bullet moved to position {bullet2.position}\")\n\n# Release the second bullet\nbullet_pool.release(bullet2)\nprint(f\"Bullet released back to pool from position {bullet2.position}\")\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    pool := GetInstance()\n\n    // Acquire a bullet and simulate firing it\n    bullet := pool.Acquire()\n    bullet.Position = 10 // Set starting position\n    fmt.Printf(\"Bullet fired from position %d\\n\", bullet.Position)\n\n    // Move the bullet and draw it\n    bullet.Move()\n    bullet.Draw()\n\n    // Release the bullet back to the pool\n    pool.Release(bullet)\n    fmt.Println(\"Bullet released and returned to pool\")\n}\n</code></pre>"},{"location":"design-patterns/creational/prototype/","title":"Prototype Pattern","text":""},{"location":"design-patterns/creational/prototype/#description","title":"Description","text":"<p>Prototype is a creational design pattern that lets you copy existing objects without making your code dependent on their classes. Normally, to copy an object, you'd have to create that object and then copy its fields over. But some of those fields may be private, or the class itself may be an interface.</p> <p>The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single <code>clone</code> method.</p> <p><code>clone</code>: creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.</p>"},{"location":"design-patterns/creational/prototype/#benefits","title":"Benefits","text":"<ol> <li>Simplifies object creation: The pattern simplifies the creation of complex objects by cloning a prototype, reducing the complexity associated with creating new instances from scratch.</li> </ol>"},{"location":"design-patterns/creational/prototype/#example","title":"Example","text":"<p>Let's consider a scenario where you have a shape interface with concrete implementations for different types of shapes. You can create clones of these shapes without depending on their specific classes.</p> <p>In this example:</p> <ul> <li>The <code>Shape</code> is the prototype interface. </li> <li><code>Circle</code> and <code>Rectangle</code> are the concrete prototypes. </li> </ul>"},{"location":"design-patterns/creational/prototype/#implementation","title":"Implementation","text":"<ul> <li>The <code>Shape</code> interface has <code>clone()</code>, <code>get_area()</code>, and <code>get_sides()</code></li> <li><code>Circle</code>'s constructor needs only a radius while <code>Rectangle</code> needs width and height</li> <li>Each shape implements clone differently - but call the constructor, passing in its own fields.</li> </ul>"},{"location":"design-patterns/creational/prototype/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Shape {\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n    }\n\n    class Circle {\n        +int radius\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n        +String toString()\n    }\n\n    class Rectangle {\n        +int width\n        +int height\n        +clone() Shape\n        +get_area() float\n        +get_sides() int\n        +String toString()\n    }\n\n    Shape &lt;|-- Circle\n    Shape &lt;|-- Rectangle\n</code></pre>"},{"location":"design-patterns/creational/prototype/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nimport math\n\n\n# Prototype interface\nclass Shape(ABC):\n    @abstractmethod\n    def clone(self):\n        pass\n\n    @abstractmethod\n    def get_area(self):\n        pass\n\n    @abstractmethod\n    def get_sides(self):\n        pass\n\n\n# Concrete prototype\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def clone(self):\n        # Create a new instance of Circle and copy all fields\n        new_circle = Circle(self.radius)\n        return new_circle\n\n    def get_area(self):\n        return math.pi * self.radius**2\n\n    def get_sides(self):\n        return 0\n\n    def __str__(self):\n        return f\"Circle with radius {self.radius}\"\n\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def clone(self):\n        # Create a new instance of Rectangle and copy all fields\n        new_rectangle = Rectangle(self.width, self.height)\n        return new_rectangle\n\n    def get_area(self):\n        return self.width * self.height\n\n    def get_sides(self):\n        return 4\n\n    def __str__(self):\n        return f\"Rectangle with width {self.width} and height {self.height}\"\n</code></pre> <pre><code>package prototype\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// Prototype interface\ntype Shape interface {\n    Clone() Shape\n    GetArea() float64\n    GetSides() int\n}\n\n// Concrete prototype\ntype Circle struct {\n    Radius int\n}\n\nfunc (c *Circle) Clone() Shape {\n    // Create a new instance of Circle and copy all fields\n    return &amp;Circle{Radius: c.Radius}\n}\n\nfunc (c *Circle) GetArea() float64 {\n    return math.Pi * float64(c.Radius) * float64(c.Radius)\n}\n\nfunc (c *Circle) GetSides() int {\n    return 0\n}\n\nfunc (c *Circle) String() string {\n    return fmt.Sprintf(\"Circle with radius %d\", c.Radius)\n}\n\ntype Rectangle struct {\n    Width, Height int\n}\n\nfunc (r *Rectangle) Clone() Shape {\n    // Create a new instance of Rectangle and copy all fields\n    return &amp;Rectangle{Width: r.Width, Height: r.Height}\n}\n\nfunc (r *Rectangle) GetArea() float64 {\n    return float64(r.Width * r.Height)\n}\n\nfunc (r *Rectangle) GetSides() int {\n    return 4\n}\n\nfunc (r *Rectangle) String() string {\n    return fmt.Sprintf(\"Rectangle with width %d and height %d\", r.Width, r.Height)\n}\n</code></pre>"},{"location":"design-patterns/creational/prototype/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from prototype import Circle, Rectangle\n\n# Client code\ncircle1 = Circle(5)\ncircle2 = circle1.clone()\nrectangle1 = Rectangle(3, 4)\nrectangle2 = rectangle1.clone()\n\nprint(circle1)  # Output: Circle with radius 5\nprint(circle2)  # Output: Circle with radius 5\nprint(f\"Circle area: {circle1.get_area()}\")  # Output: Circle area: 78.53981633974483\nprint(f\"Circle sides: {circle1.get_sides()}\")  # Output: Circle sides: 0\nprint(rectangle1)  # Output: Rectangle with width 3 and height 4\nprint(rectangle2)  # Output: Rectangle with width 3 and height 4\nprint(f\"Rectangle area: {rectangle1.get_area()}\")  # Output: Rectangle area: 12\nprint(f\"Rectangle sides: {rectangle1.get_sides()}\")  # Output: Rectangle sides: 4\n</code></pre> <pre><code>package prototype\n\nimport \"fmt\"\n\n// Client code\nfunc main() {\n    circle1 := &amp;Circle{Radius: 5}\n    circle2 := circle1.Clone()\n    rectangle1 := &amp;Rectangle{Width: 3, Height: 4}\n    rectangle2 := rectangle1.Clone()\n\n    fmt.Println(circle1)                                       // Output: Circle with radius 5\n    fmt.Println(circle2)                                       // Output: Circle with radius 5\n    fmt.Printf(\"Circle area: %f\\n\", circle1.GetArea())         // Output: Circle area: 78.539816\n    fmt.Printf(\"Circle sides: %d\\n\", circle1.GetSides())       // Output: Circle sides: 0\n    fmt.Println(rectangle1)                                    // Output: Rectangle with width 3 and height 4\n    fmt.Println(rectangle2)                                    // Output: Rectangle with width 3 and height 4\n    fmt.Printf(\"Rectangle area: %f\\n\", rectangle1.GetArea())   // Output: Rectangle area: 12.000000\n    fmt.Printf(\"Rectangle sides: %d\\n\", rectangle1.GetSides()) // Output: Rectangle sides: 4\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/","title":"Singleton Pattern","text":""},{"location":"design-patterns/creational/singleton/#description","title":"Description","text":"<p>The Singleton Pattern ensures a class has only one instance and provides a global point of access to it. This pattern is useful when exactly one object is needed to coordinate actions across the system.</p>"},{"location":"design-patterns/creational/singleton/#benefits","title":"Benefits","text":"<ol> <li> <p>Controlled Access to a Single Instance: The Singleton Pattern ensures that there is precisely one instance of a class, which is particularly useful when managing shared resources like configuration settings or logging.</p> </li> <li> <p>Reduced Namespace Pollution: By providing a single point of access, the Singleton Pattern avoids the proliferation of global variables and reduces the risk of naming conflicts.</p> </li> <li> <p>Lazy Initialization: Singleton can be initialized only when it's needed, rather than when the application starts. This can lead to better resource management.</p> </li> <li> <p>Global Access Point: Singleton provides a global access point to an instance, making it easy to use and access the singleton instance throughout the application.</p> </li> <li> <p>Consistency: Ensures that all components of an application use the same instance, leading to consistent behavior and state across the application.</p> </li> <li> <p>Resource Management: Useful for managing limited resources, such as database connections or thread pools, by ensuring that only one instance is used to manage these resources.</p> </li> </ol>"},{"location":"design-patterns/creational/singleton/#example","title":"Example","text":"<p>Imagine you are building a web application that needs to interact with a database. Creating a new database connection every time a request is made would be inefficient and resource-intensive. Instead, you can use the Singleton Pattern to ensure that only one database connection is created and shared across the entire application.</p> <p>In this example:</p> <ul> <li>The database connection is the Singleton.</li> <li>The Singleton Pattern ensures that the application creates only one database connection and uses it for all database operations.</li> <li>This approach improves performance by reducing the overhead of establishing multiple connections and ensures consistent access to the database.</li> </ul>"},{"location":"design-patterns/creational/singleton/#implementation","title":"Implementation","text":"<ul> <li>The Singleton Class's contructor is normal - does everything a normal contructor would do, except it is <code>private</code>!</li> <li><code>getInstance()</code> static method that returns the instance<ul> <li>if no instance, (acquire thread lock if parallel), call private constructor</li> <li>otherwise return instance</li> </ul> </li> </ul>"},{"location":"design-patterns/creational/singleton/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Singleton {\n        -static instance: Singleton\n        -Singleton()\n        +static getInstance(): Singleton\n    }\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class Singleton:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:  # check if the static instance already exists\n            # calls __new__ method of the parent (object) class\n            # basically calling object.__new__(Singleton)\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not hasattr(self, \"initialized\"):\n            self.initialized = True  # Avoid reinitialization\n            self.value = 42\n\n    # Public methods (business logic)\n    def get_value(self):\n        return self.value\n\n    def set_value(self, value):\n        self.value = value\n</code></pre> <pre><code>package implementation\n\nimport (\n    \"sync\"\n)\n\n// lowercase singleton struct so it is not accessible outside the package (not exported)\ntype singleton struct {\n    value int\n}\n\n// declare package level variables\nvar (\n    instance *singleton // Pointer to the singleton instance (initialized to nil)\n    once     sync.Once  // used to ensure the singleton is created only once (even with goroutines) (initialized to zero value of sync.Once)\n)\n\n// GetInstance returns the singleton instance of singleton\nfunc GetInstance() *singleton { // returns a pointer to the singleton instance\n    once.Do(func() {\n        // instance is set to the address of a new singleton instance with value 42\n        // singleton's constructor is private, so it can only be created within the package\n        instance = &amp;singleton{value: 42}\n    })\n    return instance\n}\n\n// GetValue returns the value of the singleton instance\nfunc (s *singleton) GetValue() int {\n    return s.value\n}\n\n// SetValue sets the value of the singleton instance\nfunc (s *singleton) SetValue(value int) {\n    s.value = value\n}\n</code></pre>"},{"location":"design-patterns/creational/singleton/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from singleton_implementation import Singleton\n\n# Example usage\nsingleton1 = Singleton()\nsingleton2 = Singleton()\n\n# Ensure both variables point to the same instance\nassert singleton1 is singleton2\n\n# Ensure the initial value is correct\nassert singleton1.get_value() == singleton2.get_value() == 42\n\n# Set a new value using one instance\nsingleton1.set_value(100)\n\n# Ensure both instances reflect the new value\nassert singleton1.get_value() == singleton2.get_value() == 100\n\nprint(\"Singleton works correctly!\")\n</code></pre> <pre><code>package usage\n\nimport (\n    // Standard library packages\n    \"testing\"\n\n    // External package\n    impl \"tkh/code/design-patterns/creational/singleton/go/implementation\"\n)\n\nfunc TestSingleton(t *testing.T) {\n    singleton1 := impl.GetInstance()\n    singleton2 := impl.GetInstance()\n\n    // Ensure both variables point to the same instance\n    if singleton1 != singleton2 {\n        t.Errorf(\"Expected singleton1 and singleton2 to be the same instance, but they are not\")\n    }\n\n    // Ensure the initial value is correct\n    if singleton1.GetValue() != 42 || singleton2.GetValue() != 42 {\n        t.Errorf(\"Expected initial value to be 42, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // Set a new value using one instance\n    singleton1.SetValue(100)\n\n    // Ensure both instances reflect the new value\n    if singleton1.GetValue() != 100 || singleton2.GetValue() != 100 {\n        t.Errorf(\"Expected value to be updated to 100, but got %d and %d\", singleton1.GetValue(), singleton2.GetValue())\n    }\n\n    // log that we are done testing\n    t.Log(\"Done testing singleton\")\n}\n</code></pre>"},{"location":"design-patterns/structural/adapter/","title":"Adapter Pattern","text":""},{"location":"design-patterns/structural/adapter/#description","title":"Description","text":"<p>The Adapter pattern is a structural design pattern that allows objects with incompatible objects to work collaborate. It acts as a bridge between two otherwise incompatible interfaces by wrapping itself around an object and presenting a different interface. This is particularly useful when integrating new components into existing systems where interfaces do not match.</p>"},{"location":"design-patterns/structural/adapter/#benefits","title":"Benefits","text":"<ol> <li>Increased Compatibility: Allows two different interfaces to work together without modifying their source code.</li> <li>Reusability: Enables the reuse of existing classes even if their interfaces do not match the required business environment.</li> </ol>"},{"location":"design-patterns/structural/adapter/#example","title":"Example","text":"<p>Imagine you have developed a video player application that initially supports only MP4 files. Over time, you want to expand its capabilities to support additional formats like AVI and MKV without modifying the existing media player code.</p> <p>In this example:</p> <ul> <li><code>MP4Player</code> represents the original system designed to play MP4 files.</li> <li><code>MediaAdapter</code> adapts other types of media interfaces (like AVI and MKV players) to the interface expected by the existing video player application.</li> </ul>"},{"location":"design-patterns/structural/adapter/#implementation","title":"Implementation","text":"<p>Inheritance is not strictly necessary, but it is commonly used to achieve interface compatibility, especially in languages that support it. The pattern can be implemented in two main ways: the class adapter approach using inheritance, and the object adapter approach using composition. Here - we do not use inheritance.</p> <ul> <li><code>VideoPlayer</code> is the <code>Target</code> and the main class that uses the <code>MediaAdapter</code> to play different types of media files.<ul> <li>The <code>Target</code> defines the domain-specific interface that the client uses. This is the interface that the adapter must adapt the adaptee to match. </li> </ul> </li> <li>The <code>AVIPlayer</code> class is an <code>Adaptee</code> and a new system that plays AVI files. (new system) (Adaptee)</li> <li>The <code>MP4Player</code> class is an <code>Adaptee</code> and is the original system that plays MP4 files. (legacy system)</li> <li>The <code>MediaAdapter</code> implements the same interface as the <code>MP4Player</code> but uses different media player implementations to handle various formats. As you can see, this class makes it possible for the <code>VideoPlayer</code> to play different types of media files by providing the necessary conversion. The adapter's <code>play</code> method is responsible for determining the type of media file and delegating the request to the appropriate adaptee.</li> </ul>"},{"location":"design-patterns/structural/adapter/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class VideoPlayer {\n        +play(fileType, fileName)\n    }\n\n    class MP4Player {\n        +playMP4(fileName)\n    }\n\n    class AVIPlayer {\n        +playAVI(fileName)\n    }\n\n    class MediaAdapter {\n        -player Object\n        +play(fileType, fileName)\n    }\n\n    VideoPlayer --&gt; MediaAdapter: uses\n    MediaAdapter --&gt; MP4Player: adapts\n    MediaAdapter --&gt; AVIPlayer: adapts\n</code></pre>"},{"location":"design-patterns/structural/adapter/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class MP4Player:\n    def playMP4(self, fileName):\n        print(f\"Playing MP4 file: {fileName}\")\n\n\nclass AVIPlayer:\n    def playAVI(self, fileName):\n        print(f\"Playing AVI file: {fileName}\")\n\n\nclass MediaAdapter:\n    def __init__(self, fileType):\n        if fileType == \"avi\":\n            self.player = AVIPlayer()\n        else:\n            self.player = None\n\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        elif fileType == \"avi\":\n            self.player.playAVI(fileName)\n\n\nclass VideoPlayer:\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        else:\n            adapter = MediaAdapter(fileType)\n            adapter.play(fileType, fileName)\n</code></pre> <pre><code>package adapter\n\nimport \"fmt\"\n\n// MP4Player is a simple struct to play MP4 files.\ntype MP4Player struct{}\n\n// PlayMP4 is a method to play MP4 files.\nfunc (mp *MP4Player) PlayMP4(fileName string) {\n    fmt.Printf(\"Playing MP4 file: %s\\n\", fileName)\n}\n\n// AVIPlayer is a simple struct to play AVI files.\ntype AVIPlayer struct{}\n\n// PlayAVI is a method to play AVI files.\nfunc (av *AVIPlayer) PlayAVI(fileName string) {\n    fmt.Printf(\"Playing AVI file: %s\\n\", fileName)\n}\n\n// MediaAdapter is an adapter for media players that do not match the required method signature.\ntype MediaAdapter struct {\n    player *AVIPlayer\n}\n\n// NewMediaAdapter creates a new MediaAdapter instance based on the fileType.\nfunc NewMediaAdapter(fileType string) *MediaAdapter {\n    if fileType == \"avi\" {\n        return &amp;MediaAdapter{player: &amp;AVIPlayer{}}\n    }\n    return nil\n}\n\n// Play checks the fileType and plays the file using the appropriate method.\nfunc (ma *MediaAdapter) Play(fileType, fileName string) {\n    if fileType == \"avi\" &amp;&amp; ma.player != nil {\n        ma.player.PlayAVI(fileName)\n    }\n}\n\n// VideoPlayer can play different formats by using the appropriate player or adapter.\ntype VideoPlayer struct{}\n\n// Play determines how to play the media based on the file type.\nfunc (vp *VideoPlayer) Play(fileType, fileName string) {\n    if fileType == \"mp4\" {\n        player := MP4Player{}\n        player.PlayMP4(fileName)\n    } else {\n        adapter := NewMediaAdapter(fileType)\n        if adapter != nil {\n            adapter.Play(fileType, fileName)\n        } else {\n            fmt.Println(\"Unsupported file type\")\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/adapter/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from adapter import VideoPlayer\n\n# Create an instance of VideoPlayer\nvideo_player = VideoPlayer()\n\n# Play an MP4 file\nprint(\"Testing MP4 Playback:\")\nvideo_player.play(\"mp4\", \"sample.mp4\")\n\n# Play an AVI file\nprint(\"\\nTesting AVI Playback:\")\nvideo_player.play(\"avi\", \"example.avi\")\n</code></pre> <pre><code>package adapter\n\nimport \"testing\"\n\nfunc TestVideoPlayer(t *testing.T) {\n    vp := VideoPlayer{}\n    vp.Play(\"mp4\", \"example.mp4\") // Should output: Playing MP4 file: example.mp4\n    vp.Play(\"avi\", \"example.avi\") // Should output: Playing AVI file: example.avi\n}\n</code></pre>"},{"location":"design-patterns/structural/bridge/","title":"Bridge Pattern","text":""},{"location":"design-patterns/structural/bridge/#description","title":"Description","text":"<p>Bridge is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies\u2014abstraction and implementation\u2014which can be developed independently of each other.</p> <p>abstraction - The high level control layer for some entity. This does not do work and simply delegates to the <code>implementation</code> layer. (example: abstraction is UI and implementation is Backend)</p> <p>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app/legacy code to make some otherwise-incompatible classes work together nicely.</p>"},{"location":"design-patterns/structural/bridge/#benefits","title":"Benefits","text":"<ol> <li>Decoupling: Separates the abstraction from the implementation, allowing them to be developed independently.</li> <li>Flexibility: Enables the implementation of the abstraction to change dynamically at runtime.</li> <li>Scalability: Facilitates the addition of new abstractions and implementations without altering existing code.</li> </ol>"},{"location":"design-patterns/structural/bridge/#example","title":"Example","text":"<p>Say, you have two types of computers: Mac and Windows. Also, two types of printers: Epson and HP. Both computers and printers need to work with each other in any combination. The client doesn\u2019t want to worry about the details of connecting printers to computers.</p> <p>If we introduce new printers, we don\u2019t want our code to grow exponentially. Instead of creating four structs for the 2*2 combination, we create two hierarchies:</p> <p>In this example:</p> <ul> <li><code>Abstraction</code>: the computers.</li> <li><code>Implementation</code>: the printers.</li> </ul>"},{"location":"design-patterns/structural/bridge/#implementation","title":"Implementation","text":"<ul> <li>The <code>Abstraction</code> (Conputer) contains a reference to the <code>Implementor</code> (Printer) and delegates all work to it.</li> <li>The <code>Implementor</code> (Device) is an interface that defines the operations that the <code>ConcreteImplementors</code> (HPPrinter and EpsonPrinter) must implement.</li> </ul>"},{"location":"design-patterns/structural/bridge/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Computer {\n        -printer: Printer\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class Printer {\n        +print()\n    }\n\n    class Mac {\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class Windows {\n        +setPrinter(printer: Printer)\n        +print()\n    }\n\n    class HPPrinter {\n        +print()\n    }\n\n    class EpsonPrinter {\n        +print()\n    }\n\n    Computer --&gt; Printer: uses\n    Mac --&gt; Computer: extends\n    Windows --&gt; Computer: extends\n    HPPrinter --&gt; Printer: implements\n    EpsonPrinter --&gt; Printer: implements\n</code></pre>"},{"location":"design-patterns/structural/bridge/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class MP4Player:\n    def playMP4(self, fileName):\n        print(f\"Playing MP4 file: {fileName}\")\n\n\nclass AVIPlayer:\n    def playAVI(self, fileName):\n        print(f\"Playing AVI file: {fileName}\")\n\n\nclass MediaAdapter:\n    def __init__(self, fileType):\n        if fileType == \"avi\":\n            self.player = AVIPlayer()\n        else:\n            self.player = None\n\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        elif fileType == \"avi\":\n            self.player.playAVI(fileName)\n\n\nclass VideoPlayer:\n    def play(self, fileType, fileName):\n        if fileType == \"mp4\":\n            MP4Player().playMP4(fileName)\n        else:\n            adapter = MediaAdapter(fileType)\n            adapter.play(fileType, fileName)\n</code></pre> <pre><code>package adapter\n\nimport \"fmt\"\n\n// MP4Player is a simple struct to play MP4 files.\ntype MP4Player struct{}\n\n// PlayMP4 is a method to play MP4 files.\nfunc (mp *MP4Player) PlayMP4(fileName string) {\n    fmt.Printf(\"Playing MP4 file: %s\\n\", fileName)\n}\n\n// AVIPlayer is a simple struct to play AVI files.\ntype AVIPlayer struct{}\n\n// PlayAVI is a method to play AVI files.\nfunc (av *AVIPlayer) PlayAVI(fileName string) {\n    fmt.Printf(\"Playing AVI file: %s\\n\", fileName)\n}\n\n// MediaAdapter is an adapter for media players that do not match the required method signature.\ntype MediaAdapter struct {\n    player *AVIPlayer\n}\n\n// NewMediaAdapter creates a new MediaAdapter instance based on the fileType.\nfunc NewMediaAdapter(fileType string) *MediaAdapter {\n    if fileType == \"avi\" {\n        return &amp;MediaAdapter{player: &amp;AVIPlayer{}}\n    }\n    return nil\n}\n\n// Play checks the fileType and plays the file using the appropriate method.\nfunc (ma *MediaAdapter) Play(fileType, fileName string) {\n    if fileType == \"avi\" &amp;&amp; ma.player != nil {\n        ma.player.PlayAVI(fileName)\n    }\n}\n\n// VideoPlayer can play different formats by using the appropriate player or adapter.\ntype VideoPlayer struct{}\n\n// Play determines how to play the media based on the file type.\nfunc (vp *VideoPlayer) Play(fileType, fileName string) {\n    if fileType == \"mp4\" {\n        player := MP4Player{}\n        player.PlayMP4(fileName)\n    } else {\n        adapter := NewMediaAdapter(fileType)\n        if adapter != nil {\n            adapter.Play(fileType, fileName)\n        } else {\n            fmt.Println(\"Unsupported file type\")\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/bridge/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from adapter import VideoPlayer\n\n# Create an instance of VideoPlayer\nvideo_player = VideoPlayer()\n\n# Play an MP4 file\nprint(\"Testing MP4 Playback:\")\nvideo_player.play(\"mp4\", \"sample.mp4\")\n\n# Play an AVI file\nprint(\"\\nTesting AVI Playback:\")\nvideo_player.play(\"avi\", \"example.avi\")\n</code></pre> <pre><code>package adapter\n\nimport \"testing\"\n\nfunc TestVideoPlayer(t *testing.T) {\n    vp := VideoPlayer{}\n    vp.Play(\"mp4\", \"example.mp4\") // Should output: Playing MP4 file: example.mp4\n    vp.Play(\"avi\", \"example.avi\") // Should output: Playing AVI file: example.avi\n}\n</code></pre>"},{"location":"design-patterns/structural/composite/","title":"Composite Pattern","text":""},{"location":"design-patterns/structural/composite/#description","title":"Description","text":"<p>Composite is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.</p> <p>Great pattern for working with tree structures and using recursion over the structure. </p>"},{"location":"design-patterns/structural/composite/#benefits","title":"Benefits","text":"<ol> <li>Simplifies Client Code: You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.</li> <li>Flexibility: The pattern allows you to create complex structures by composing objects into tree structures. This makes it easy to add new types of objects to the structure without changing the client code.</li> </ol>"},{"location":"design-patterns/structural/composite/#example","title":"Example","text":"<p>On your computer your file system can have files and directories. Let's say you want to calculate the size of all objects in a directory. This memory calculation operation applies to both files and folders</p> <p>In this example:</p> <ul> <li><code>Component</code>: the interface that defines the operations that can be performed on both files and directories.</li> <li><code>Leaf</code>: the class that represents a file.</li> <li><code>Composite</code>: the class that represents a directory and can contain both files and other directories.</li> </ul>"},{"location":"design-patterns/structural/composite/#implementation","title":"Implementation","text":"<ul> <li>The <code>Component</code> interface has a <code>calculateSize</code> method that calculates the size of the object.</li> <li>The <code>Directory</code> class is a <code>Composite</code> that can contain both files and directories. It implements the <code>Component</code> interface and delegates the <code>calculateSize</code> operation to its children.</li> <li>The <code>File</code> class is a <code>Leaf</code> that represents a file. It also implements the <code>Component</code> interface and provides the implementation for the <code>calculateSize</code> method.</li> </ul>"},{"location":"design-patterns/structural/composite/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Component {\n        +calculateSize() int\n    }\n\n    class File {\n        -name: string\n        -size: int\n        +calculateSize() int\n    }\n\n    class Directory {\n        -name: string\n        -children: List~Component~\n        +add(component: Component)\n        +calculateSize() int\n    }\n\n    Component &lt;|-- File: implements\n    Component &lt;|-- Directory: implements\n</code></pre>"},{"location":"design-patterns/structural/composite/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\nfrom typing import List\n\n\nclass Component(ABC):\n    @abstractmethod\n    def calculate_size(self) -&gt; int:\n        pass\n\n\nclass File(Component):\n    def __init__(self, name: str, size: int):\n        self.name = name\n        self.size = size\n\n    def calculate_size(self) -&gt; int:\n        return self.size\n\n\nclass Directory(Component):\n    def __init__(self, name: str):\n        self.name = name\n        self.children: List[Component] = []\n\n    def add(self, component: Component):\n        self.children.append(component)\n\n    def calculate_size(self) -&gt; int:\n        total_size = 0\n        for child in self.children:\n            total_size += child.calculate_size()\n        return total_size\n</code></pre> <pre><code>package composite\n\ntype Component interface {\n    calculateSize() int\n}\n\ntype Folder struct {\n    components []Component\n    name       string\n}\n\nfunc (f *Folder) calculateSize() int {\n    size := 0\n    for _, component := range f.components {\n        size += component.calculateSize()\n    }\n    return size\n}\n\nfunc (f *Folder) add(component Component) {\n    f.components = append(f.components, component)\n}\n\ntype File struct {\n    size int\n    name string\n}\n\nfunc (f *File) calculateSize() int {\n    return f.size\n}\n</code></pre>"},{"location":"design-patterns/structural/composite/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from composite import File, Directory\n\nfile1 = File(\"File1.txt\", 100)\nfile2 = File(\"File2.txt\", 150)\n\ndir1 = Directory(\"Dir1\")\ndir2 = Directory(\"Dir2\")\n\n# Adding files to directories\ndir1.add(file1)\ndir1.add(file2)\n\n# Adding directory to another directory\ndir2.add(dir1)\n\n# Calculating sizes\nprint(f\"Size of {file1.name}: {file1.calculate_size()} bytes\")\nprint(f\"Size of {dir1.name}: {dir1.calculate_size()} bytes\")\nprint(f\"Size of {dir2.name}: {dir2.calculate_size()} bytes\")\n\nassert dir1.calculate_size() == 250\nassert dir2.calculate_size() == 250\n</code></pre> <pre><code>package composite\n\nimport \"testing\"\n\nfunc TestCompositePattern(t *testing.T) {\n    file1 := &amp;File{name: \"File1.txt\", size: 100}\n    file2 := &amp;File{name: \"File2.txt\", size: 150}\n\n    dir1 := &amp;Folder{name: \"Dir1\"}\n    dir2 := &amp;Folder{name: \"Dir2\"}\n\n    // Adding files to directories\n    dir1.add(file1)\n    dir1.add(file2)\n\n    // Adding directory to another directory\n    dir2.add(dir1)\n\n    // Asserting sizes\n    if file1.calculateSize() != 100 {\n        t.Errorf(\"Expected size of file1: 100, but got %d\", file1.calculateSize())\n    }\n\n    if file2.calculateSize() != 150 {\n        t.Errorf(\"Expected size of file2: 150, but got %d\", file2.calculateSize())\n    }\n\n    if dir1.calculateSize() != 250 {\n        t.Errorf(\"Expected size of dir1: 250, but got %d\", dir1.calculateSize())\n    }\n\n    if dir2.calculateSize() != 250 {\n        t.Errorf(\"Expected size of dir2: 250, but got %d\", dir2.calculateSize())\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/decorator/","title":"Decorator Pattern","text":""},{"location":"design-patterns/structural/decorator/#description","title":"Description","text":"<p>Decorator - also known as \u201cWrapper\u201d - is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</p> <p>Decorator extends an existing interface and allows for recursive composition (multiple decorators) while Adapter provides a completely different interface for accessing an existing object. </p>"},{"location":"design-patterns/structural/decorator/#benefits","title":"Benefits","text":"<ol> <li>Extensibility: You can extend an object\u2019s behavior without making a new subclass. Or combine several behaviors by wrapping an object into multiple decorators.</li> <li>Flexibility: You can add or remove responsibilities from an object at runtime.</li> </ol>"},{"location":"design-patterns/structural/decorator/#example","title":"Example","text":"<p>Imagine that you\u2019re working on a notification library which lets other programs notify their users about important events. \\</p> <p>Initially, the library only consisted of the <code>Notification</code> class with a <code>send()</code> method for emails. Now, we want to add support for SMS, Facebook, and Slack. </p> <p>Instead, we can create a set of decorators, each implementing the <code>Notifier</code> interface and adding a specific <code>send()</code> method.</p> <p>In this example:</p> <ul> <li><code>Notifier</code> is the interface that defines the operations that can be performed on a notification.</li> <li><code>BaseNotifierDecorator</code> is the abstract class that wraps a <code>Notifier</code> object and implements the <code>Notifier</code> interface.</li> <li><code>EmailNotifier</code>, <code>SMSNotifier</code>, <code>FacebookNotifier</code>, and <code>SlackNotifier</code> are concrete decorators that add specific behaviors to the notification and also implement <code>send()</code> method.</li> </ul>"},{"location":"design-patterns/structural/decorator/#implementation","title":"Implementation","text":"<ul> <li>The Wrapper/Decorator (<code>BaseNotifierDecorator</code>) should implement the same interface as the wrapped object.</li> <li>The concrete decorators (<code>EmailNotifier</code>, <code>SMSNotifier</code>, <code>FacebookNotifier</code>, <code>SlackNotifier</code>) should extend the <code>BaseNotifierDecorator</code> and add specific behaviors to the notification.</li> <li>The constructor of the concrete decorators should accept a <code>Notifier</code> - allowing for recursive composition. i.e <code>decorator1(decorator2(decorator3(object)))</code></li> </ul>"},{"location":"design-patterns/structural/decorator/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Notifier {\n        +send()\n    }\n\n    class BaseNotifierDecorator {\n        -Notifier wrappedNotifier\n        +BaseNotifierDecorator(Notifier notifier)\n        +send()\n    }\n\n    class EmailNotifier {\n        +EmailNotifier(Notifier notifier)\n        +send()\n    }\n\n    class SMSNotifier {\n        +SMSNotifier(Notifier notifier)\n        +send()\n    }\n\n    class FacebookNotifier {\n        +FacebookNotifier(Notifier notifier)\n        +send()\n    }\n\n    class SlackNotifier {\n        +SlackNotifier(Notifier notifier)\n        +send()\n    }\n\n    Notifier &lt;|.. BaseNotifierDecorator\n    BaseNotifierDecorator &lt;|-- EmailNotifier\n    BaseNotifierDecorator &lt;|-- SMSNotifier\n    BaseNotifierDecorator &lt;|-- FacebookNotifier\n    BaseNotifierDecorator &lt;|-- SlackNotifier\n</code></pre>"},{"location":"design-patterns/structural/decorator/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from abc import ABC, abstractmethod\n\n\nclass Notifier(ABC):\n    @abstractmethod\n    def send(self):\n        pass\n\n\nclass BaseNotifierDecorator(Notifier):\n    def __init__(self, notifier: Notifier):\n        self._wrapped_notifier = notifier\n\n    def send(self):\n        self._wrapped_notifier.send()\n\n\nclass EmailNotifier(BaseNotifierDecorator):\n    def send(self):\n        super().send()\n        self._send_email()\n\n    def _send_email(self):\n        print(\"Sending email notification.\")\n\n\nclass SMSNotifier(BaseNotifierDecorator):\n    def send(self):\n        super().send()\n        self._send_sms()\n\n    def _send_sms(self):\n        print(\"Sending SMS notification.\")\n\n\nclass FacebookNotifier(BaseNotifierDecorator):\n    def send(self):\n        super().send()\n        self._send_facebook()\n\n    def _send_facebook(self):\n        print(\"Sending Facebook notification.\")\n\n\nclass SlackNotifier(BaseNotifierDecorator):\n    def send(self):\n        super().send()\n        self._send_slack()\n\n    def _send_slack(self):\n        print(\"Sending Slack notification.\")\n\n\n# Example usage\nclass SimpleNotifier(Notifier):\n    def send(self):\n        print(\"Basic notification.\")\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// Notifier is the interface that defines the send method.\ntype Notifier interface {\n    Send()\n}\n\n// SimpleNotifier is a basic implementation of Notifier.\ntype SimpleNotifier struct{}\n\nfunc (n *SimpleNotifier) Send() {\n    fmt.Println(\"Basic notification.\")\n}\n\n// EmailNotifier is a concrete decorator that adds email notification.\ntype EmailNotifier struct {\n    notifier Notifier\n}\n\nfunc (n *EmailNotifier) Send() {\n    n.notifier.Send()\n    n.sendEmail()\n}\n\nfunc (n *EmailNotifier) sendEmail() {\n    fmt.Println(\"Sending email notification.\")\n}\n\n// SMSNotifier is a concrete decorator that adds SMS notification.\ntype SMSNotifier struct {\n    notifier Notifier\n}\n\nfunc (n *SMSNotifier) Send() {\n    n.notifier.Send()\n    n.sendSMS()\n}\n\nfunc (n *SMSNotifier) sendSMS() {\n    fmt.Println(\"Sending SMS notification.\")\n}\n\n// FacebookNotifier is a concrete decorator that adds Facebook notification.\ntype FacebookNotifier struct {\n    notifier Notifier\n}\n\nfunc (n *FacebookNotifier) Send() {\n    n.notifier.Send()\n    n.sendFacebook()\n}\n\nfunc (n *FacebookNotifier) sendFacebook() {\n    fmt.Println(\"Sending Facebook notification.\")\n}\n\n// SlackNotifier is a concrete decorator that adds Slack notification.\ntype SlackNotifier struct {\n    notifier Notifier\n}\n\nfunc (n *SlackNotifier) Send() {\n    n.notifier.Send()\n    n.sendSlack()\n}\n\nfunc (n *SlackNotifier) sendSlack() {\n    fmt.Println(\"Sending Slack notification.\")\n}\n</code></pre>"},{"location":"design-patterns/structural/decorator/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from decorator import (\n    EmailNotifier,\n    SMSNotifier,\n    FacebookNotifier,\n    SlackNotifier,\n    SimpleNotifier,\n)\n\n# Wrap the basic notifier with multiple decorators\nnotifier = SimpleNotifier()\nnotifier = EmailNotifier(SMSNotifier(FacebookNotifier(SlackNotifier(notifier))))\n\nnotifier.send()\n</code></pre> <pre><code>package main\n\n// Example usage\nfunc main() {\n    // Wrap the basic notifier with multiple decorators\n    var notifier Notifier = &amp;SimpleNotifier{}\n    notifier = &amp;EmailNotifier{notifier}\n    notifier = &amp;SMSNotifier{notifier}\n    notifier = &amp;FacebookNotifier{notifier}\n    notifier = &amp;SlackNotifier{notifier}\n    notifier.Send()\n}\n</code></pre>"},{"location":"design-patterns/structural/facade/","title":"Facade Pattern","text":""},{"location":"design-patterns/structural/facade/#description","title":"Description","text":"<p>Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.</p> <p>Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality.</p> <p>When you call a shop to place a phone order, an operator is your facade to all services and departments of the shop. The operator provides you with a simple voice interface to the ordering system, payment gateways, and various delivery services.</p> <p>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.</p> <p>Facade defines a simplified interface to a subsystem of objects, but it doesn\u2019t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.</p> <p>Meanwhile, Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</p> <p>A Facade can be a Singleton - often the case since a single facade is usually sufficient.</p>"},{"location":"design-patterns/structural/facade/#benefits","title":"Benefits","text":"<ol> <li>Isolation:  You can isolate your code from the complexity of a subsystem.</li> </ol>"},{"location":"design-patterns/structural/facade/#example","title":"Example","text":"<p>Consider a complex library for a home entertainment system. This system includes various components like the TV, sound system, and gaming console, each with its own interface. The Facade pattern can be used to create a single interface to manage these components.</p> <p>In this example:</p> <ul> <li><code>TV</code> and <code>SoundSystem</code>, and <code>GamingConsole</code> are classes that represent the subsystem components.</li> <li><code>HomeEntertainmentFacade</code> is the facade that provides a simple interface to the subsystem, and allows you to turn on/off the system, watch a movie, play a game, etc.</li> </ul>"},{"location":"design-patterns/structural/facade/#implementation","title":"Implementation","text":"<p>Notice the subsystem interactions that the facade provides. The facade should provide a simple interface to a complex subsystem.</p> <ul> <li>The Facade (<code>HomeEntertainmentFacade</code>) should provide a simple interface to a complex subsystem.</li> <li>Playing a movie should always turn on the TV and sound system, and set the input channel.</li> <li>Playing a game should always turn on the gaming console, TV, and sound system.</li> </ul>"},{"location":"design-patterns/structural/facade/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class TV {\n        +on()\n        +off()\n        +setInputChannel()\n    }\n\n    class SoundSystem {\n        +on()\n        +off()\n        +setVolume(volume: int)\n    }\n\n    class GamingConsole {\n        +on()\n        +off()\n        +playGame()\n    }\n\n    class HomeEntertainmentFacade {\n        -TV tv\n        -SoundSystem soundSystem\n        -GamingConsole gamingConsole\n        +getInstance() HomeEntertainmentFacade\n        +watchMovie()\n        +playGame()\n    }\n\n    TV &lt;|-- HomeEntertainmentFacade\n    SoundSystem &lt;|-- HomeEntertainmentFacade\n    GamingConsole &lt;|-- HomeEntertainmentFacade\n</code></pre>"},{"location":"design-patterns/structural/facade/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>class TV:\n    def turn_on(self):\n        print(\"TV is ON\")\n\n    def turnOff(self):\n        print(\"TV is OFF\")\n\n\nclass SoundSystem:\n    def turn_on(self):\n        print(\"Sound System is ON\")\n\n    def turnOff(self):\n        print(\"Sound System is OFF\")\n\n\nclass GamingConsole:\n    def turn_on(self):\n        print(\"Gaming Console is ON\")\n\n    def turnOff(self):\n        print(\"Gaming Console is OFF\")\n\n\nclass HomeEntertainmentFacade:\n\n    def __init__(self):\n        self.tv = TV()\n        self.sound_system = SoundSystem()\n        self.gaming_console = GamingConsole()\n\n    def playGame(self):\n        self.gaming_console.turn_on()\n        self.tv.turn_on()\n        self.sound_system.turn_on()\n\n    def watchMovie(self):\n        self.tv.turn_on()\n        self.sound_system.turn_on()\n</code></pre> <pre><code>package facade\n\nimport \"fmt\"\n\n// TV struct\ntype TV struct{}\n\nfunc (t *TV) TurnOn() {\n    fmt.Println(\"TV is ON\")\n}\n\nfunc (t *TV) TurnOff() {\n    fmt.Println(\"TV is OFF\")\n}\n\n// SoundSystem struct\ntype SoundSystem struct{}\n\nfunc (s *SoundSystem) TurnOn() {\n    fmt.Println(\"Sound System is ON\")\n}\n\nfunc (s *SoundSystem) TurnOff() {\n    fmt.Println(\"Sound System is OFF\")\n}\n\n// GamingConsole struct\ntype GamingConsole struct{}\n\nfunc (g *GamingConsole) TurnOn() {\n    fmt.Println(\"Gaming Console is ON\")\n}\n\nfunc (g *GamingConsole) TurnOff() {\n    fmt.Println(\"Gaming Console is OFF\")\n}\n\n// HomeEntertainmentFacade struct\ntype HomeEntertainmentFacade struct {\n    tv            *TV\n    soundSystem   *SoundSystem\n    gamingConsole *GamingConsole\n}\n\nfunc NewHomeEntertainmentFacade() *HomeEntertainmentFacade {\n    return &amp;HomeEntertainmentFacade{\n        tv:            &amp;TV{},\n        soundSystem:   &amp;SoundSystem{},\n        gamingConsole: &amp;GamingConsole{},\n    }\n}\n\nfunc (h *HomeEntertainmentFacade) PlayGame() {\n    h.gamingConsole.TurnOn()\n    h.tv.TurnOn()\n    h.soundSystem.TurnOn()\n}\n\nfunc (h *HomeEntertainmentFacade) WatchMovie() {\n    h.tv.TurnOn()\n    h.soundSystem.TurnOn()\n}\n</code></pre>"},{"location":"design-patterns/structural/facade/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from facade import HomeEntertainmentFacade\n\nhef = HomeEntertainmentFacade()\nhef.playGame()\nhef.watchMovie()\n</code></pre> <pre><code>package main\n\nfunc main() {\n    homeEntertainment := NewHomeEntertainmentFacade()\n    homeEntertainment.PlayGame()\n    homeEntertainment.WatchMovie()\n}\n</code></pre>"},{"location":"design-patterns/structural/flyweight/","title":"Flyweight Pattern","text":""},{"location":"design-patterns/structural/flyweight/#description","title":"Description","text":"<p>flyweight is a structural design pattern that provides lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects, instead of keeping all of the data in each object.</p> <p>Let's say you made a game with particles and when you play it, it keeps crashing. Looks like each particle stores color and sprite are same for this effect, while position, movement vector and speed are unique. </p> <p>So the color and sprite are intrinsic states. While the position, movement vector and speed are extrinsic states.</p> <p>The intrinsic state is shared among multiple objects, while the extrinsic state can vary and is passed to the flyweight objects as needed. The extrinsic states of objects are moved to a container object. </p> <p>Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.</p> <p>Flyweight is like Singleton except Flyweight can have multiple instances with different intrinsic states. Also, Flyweight objects are immutable.</p> <p>You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.</p>"},{"location":"design-patterns/structural/flyweight/#benefits","title":"Benefits","text":"<ol> <li>Save memory:  Your app can spawn a huge number of similar objects. </li> </ol>"},{"location":"design-patterns/structural/flyweight/#example","title":"Example","text":"<p>Let's say you a rendering millions of tree objects in a game. Each tree has a name, color, texture, position, and size. We move the name, color, and texture to the flyweight class (TreeType). Now, our code can create trees using a flyweight factory. </p> <p>In this example:</p> <ul> <li><code>Tree</code> is the class that represents the tree object. </li> <li><code>TreeType</code> is the flyweight class that stores the intrinsic states of the tree.</li> <li><code>TreeFactory</code> is the flyweight factory that creates and manages the flyweight objects.</li> </ul>"},{"location":"design-patterns/structural/flyweight/#implementation","title":"Implementation","text":"<ul> <li><code>TreeFactory</code> has a factory method <code>getFlyweight(repeatingState)</code> - <code>getTreeType(name, color, texture)</code> that accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool.</li> <li><code>TreeFactory</code> also has a cache: <code>treeTypes: TreeType[]</code> that stores the flyweight objects.</li> <li><code>Forest</code> is the client which can <code>plantTree(x, y, name, color, texture)</code> and <code>draw()</code>.</li> <li>The key to the pattern is <code>planTree</code> which uses the <code>TreeFactory</code> to reuse the flyweight objects. So multiple trees can share the same <code>TreeType</code> object. Thus, saving memory.</li> </ul>"},{"location":"design-patterns/structural/flyweight/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class Tree {\n        -TreeType type\n        -x\n        -y\n        +draw(canvas)\n    }\n\n    class TreeType {\n        -name\n        -color\n        -texture\n        +TreeType(name, color, texture)\n        +draw(canvas x, y)\n    }\n\n    class TreeFactory {\n        -TreeType[] treeTypes\n        +getTreeType(name, color, texture) TreeType\n    }\n\n    class Forest {\n        -Tree[] trees\n        +plantTree(int x, int y, String name, String color, String texture)\n        +draw()\n    }\n\n    Tree &lt;|--  TreeType\n    TreeFactory &lt;|--  TreeType\n    Forest &lt;|-- Tree\n\n</code></pre>"},{"location":"design-patterns/structural/flyweight/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from typing import List\n\n\nclass TreeType:\n    def __init__(self, name, color, texture):\n        self.name = name\n        self.color = color\n        self.texture = texture\n\n\nclass Tree:\n    def __init__(self, x, y, tree_type: TreeType):\n        self.x = x\n        self.y = y\n        self.tree_type = tree_type\n\n    def draw(self, canvas, x, y):\n        print(\"Drawing on canvas\")\n\n\nclass TreeFactory:\n    tree_types: List[TreeType] = []\n\n    def get_tree_type(self, name, color, texture) -&gt; TreeType:\n        # Look for existing tree type\n        for tree_type in self.tree_types:\n            if (\n                tree_type.name == name\n                and tree_type.color == color\n                and tree_type.texture == texture\n            ):\n                return tree_type\n        # If not found, create a new one and add it to the list\n        tree_type = TreeType(name, color, texture)\n        self.tree_types.append(tree_type)\n        return tree_type\n\n\nclass Forest:\n\n    def __init__(self):\n        self.trees: List[Tree] = []\n\n    def plant_tree(self, x, y, name, color, texture) -&gt; Tree:\n        tree_type = TreeFactory().get_tree_type(name, color, texture)\n        tree = Tree(x, y, tree_type)\n        self.trees.append(tree)\n        return tree\n\n    def draw(self, canvas):\n        for tree in self.trees:\n            tree.draw(canvas, tree.x, tree.y)\n</code></pre> <pre><code>package flyweight\n\nimport (\n    \"fmt\"\n)\n\n// TreeType represents the shared intrinsic state of a tree\ntype TreeType struct {\n    Name    string\n    Color   string\n    Texture string\n}\n\n// Tree represents a tree object with extrinsic state (x, y) and intrinsic state (TreeType)\ntype Tree struct {\n    X        int\n    Y        int\n    TreeType *TreeType\n}\n\n// Draw simulates drawing the tree on a canvas\nfunc (t *Tree) Draw(canvas string) {\n    fmt.Printf(\"Drawing tree on %s at (%d, %d) with type (%s, %s, %s)\\n\",\n        canvas, t.X, t.Y, t.TreeType.Name, t.TreeType.Color, t.TreeType.Texture)\n}\n\n// TreeFactory manages the creation and reuse of TreeType instances\ntype TreeFactory struct {\n    treeTypes []*TreeType\n}\n\n// GetTreeType returns an existing TreeType if found, or creates a new one\nfunc (f *TreeFactory) GetTreeType(name, color, texture string) *TreeType {\n    for _, treeType := range f.treeTypes {\n        if treeType.Name == name &amp;&amp; treeType.Color == color &amp;&amp; treeType.Texture == texture {\n            return treeType\n        }\n    }\n    treeType := &amp;TreeType{Name: name, Color: color, Texture: texture}\n    f.treeTypes = append(f.treeTypes, treeType)\n    return treeType\n}\n\n// Forest represents a collection of trees\ntype Forest struct {\n    trees       []*Tree\n    treeFactory *TreeFactory\n}\n\n// PlantTree plants a new tree in the forest\nfunc (f *Forest) PlantTree(x, y int, name, color, texture string) {\n    treeType := f.treeFactory.GetTreeType(name, color, texture)\n    tree := &amp;Tree{X: x, Y: y, TreeType: treeType}\n    f.trees = append(f.trees, tree)\n}\n\n// Draw draws all the trees in the forest\nfunc (f *Forest) Draw(canvas string) {\n    for _, tree := range f.trees {\n        tree.Draw(canvas)\n    }\n}\n</code></pre>"},{"location":"design-patterns/structural/flyweight/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from flyweight import Forest\n\nforest = Forest()\n# The same tree type is shared between the two trees\nforest.plant_tree(0, 0, \"Oak\", \"Green\", \"Rough\")\nforest.plant_tree(1, 1, \"Oak\", \"Green\", \"Rough\")\n</code></pre> <pre><code>package main\n\nfunc main() {\n    treeFactory := &amp;TreeFactory{}\n    // pointer to Forest struct\n    forest := &amp;Forest{\n        trees:       []*Tree{},\n        treeFactory: treeFactory,\n    }\n\n    // These two trees share the same intrinsic state (TreeType)\n    forest.PlantTree(1, 2, \"Oak\", \"Green\", \"Rough\")\n    forest.PlantTree(3, 4, \"Oak\", \"Green\", \"Rough\")\n\n    forest.PlantTree(5, 6, \"Pine\", \"Green\", \"Smooth\")\n\n    canvas := \"MyCanvas\"\n    forest.Draw(canvas)\n}\n</code></pre>"},{"location":"design-patterns/structural/proxy/","title":"Proxy Pattern","text":""},{"location":"design-patterns/structural/proxy/#description","title":"Description","text":"<p>Proxy is a structural design pattern that provides a substitute or placeholder for another object, allowing you to perform something before or after the request gets through to the original object.</p> <p>A credit card is a proxy for a bank account, which is a proxy for cash. They can all be used to pay for something (implement <code>pay()</code> interface). So it's great because we don't need to carry cash around. Also, the income is transferred to the shop owner's bank account, which is nice because we don't have to risk getting robbed on the way to the bank.</p> <p>With Adapter you access an existing object via different interface. With Proxy, the interface stays the same. With Decorator you access the object via an enhanced interface.</p> <p>Unlike Facade, Proxy has the same interface as the service object, which makes them interchangeable.</p> <p>Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.</p>"},{"location":"design-patterns/structural/proxy/#benefits","title":"Benefits","text":"<ol> <li>Open/Closed Principle You can introduce new proxies without changing the service or clients.</li> <li>The proxy works even if the service object isn\u2019t ready or is not available.</li> </ol>"},{"location":"design-patterns/structural/proxy/#example","title":"Example","text":"<p>You can make a <code>virtual proxy</code> for creating expensive objects when they are needed. And checking if clients are inactive to free up resources.</p> <p>You can make a <code>protective proxy</code> to check if the client has the necessary access permissions.</p> <p>You can make a <code>cache proxy</code> to cache the results of the expensive operations.</p> <p>You can make a <code>logging proxy</code> to log requests to the service.</p> <p>For this example let's make a Nginx proxy server that provides controlled access, rate limiting, and caching for a web server.</p> <p>In this example:</p> <ul> <li><code>ServiceInterface</code> is the interface that represents the service.</li> <li><code>WebServer</code> is the class that represents the service.</li> <li><code>Nginx</code> is the class that represents the proxy.</li> </ul>"},{"location":"design-patterns/structural/proxy/#implementation","title":"Implementation","text":"<ul> <li><code>WebServer</code> and <code>Nginx</code> both implement the <code>ServiceInterface</code>.</li> <li><code>Nginx</code> has a reference to the <code>WebServer</code> (service) object.</li> <li><code>Nginx</code> has some additional methods like <code>controlAccess()</code>, <code>rateLimit()</code>, and <code>cacheRequest()</code> that are called before or after the <code>handleRequest()</code> method of the <code>WebServer</code>.</li> </ul>"},{"location":"design-patterns/structural/proxy/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    class ServiceInterface {\n        +handleRequest()\n    }\n\n    class WebServer {\n        +handleRequest()\n    }\n\n    class Nginx {\n        -WebServer webServer\n        +handleRequest()\n        +controlAccess()\n        +rateLimit()\n        +cacheRequest()\n    }\n\n    ServiceInterface &lt;|.. WebServer\n    ServiceInterface &lt;|.. Nginx\n    Nginx ..&gt; WebServer : proxy\n</code></pre>"},{"location":"design-patterns/structural/proxy/#code-implementation","title":"Code Implementation","text":"PythonGo <pre><code>from typing import Dict\n\n\nclass ServiceInterface:\n    def handle_request(self, url: str) -&gt; str:\n        pass\n\n\nclass WebServer(ServiceInterface):\n    def handle_request(self, url: str) -&gt; str:\n        return f\"WebServer handling request for: {url}\"\n\n\nclass Nginx(ServiceInterface):\n    def __init__(self, max_requests: int):\n        self.web_server = WebServer()\n        self.rate_limiter: Dict[str, int] = {}\n        self.cache: Dict[str, str] = {}\n        self.max_requests = max_requests\n\n    def handle_request(self, url: str) -&gt; str:\n        # Check if rate limit exceeded\n        if not self.control_access(url):\n            return \"Access denied\"\n        # Check if in cache\n        if url in self.cache:\n            return f\"Returning cached response for: {url}\"\n\n        response = self.web_server.handle_request(url)\n        self.cache_request(url, response)\n        return response\n\n    def control_access(self, url: str) -&gt; bool:\n        if url in self.rate_limiter:\n            if self.rate_limiter[url] &gt;= self.max_requests:\n                return False\n            self.rate_limiter[url] += 1\n        else:\n            self.rate_limiter[url] = 1\n        return True\n\n    def cache_request(self, url: str, response: str):\n        self.cache[url] = response\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// ServiceInterface represents the interface for the service\ntype ServiceInterface interface {\n    handleRequest(url string) string\n}\n\n// WebServer represents the actual service\ntype WebServer struct{}\n\n// handleRequest handles the request directly in the WebServer\nfunc (ws *WebServer) handleRequest(url string) string {\n    return fmt.Sprintf(\"WebServer handling request for: %s\", url)\n}\n\n// Nginx represents the proxy for the WebServer\ntype Nginx struct {\n    webServer   *WebServer\n    rateLimiter map[string]int\n    cache       map[string]string\n    maxRequests int\n}\n\n// NewNginx creates a new Nginx proxy with a given maxRequests limit\nfunc NewNginx(maxRequests int) *Nginx {\n    return &amp;Nginx{\n        webServer:   &amp;WebServer{},\n        rateLimiter: make(map[string]int),\n        cache:       make(map[string]string),\n        maxRequests: maxRequests,\n    }\n}\n\n// handleRequest controls access, rate limits, and caches requests\nfunc (nginx *Nginx) handleRequest(url string) string {\n    if !nginx.controlAccess(url) {\n        return \"Access denied\"\n    }\n\n    if response, found := nginx.cache[url]; found {\n        fmt.Println(response)\n        return fmt.Sprintf(\"Returning cached response for: %s\", url)\n    }\n\n    response := nginx.webServer.handleRequest(url)\n    nginx.cacheRequest(url, response)\n    return response\n}\n\n// controlAccess checks the rate limit for the given url\nfunc (nginx *Nginx) controlAccess(url string) bool {\n    if count, exists := nginx.rateLimiter[url]; exists {\n        if count &gt;= nginx.maxRequests {\n            return false\n        }\n        nginx.rateLimiter[url]++\n    } else {\n        nginx.rateLimiter[url] = 1\n    }\n    return true\n}\n\n// cacheRequest caches the response for the given url\nfunc (nginx *Nginx) cacheRequest(url, response string) {\n    nginx.cache[url] = response\n}\n</code></pre>"},{"location":"design-patterns/structural/proxy/#code-usage","title":"Code Usage","text":"PythonGo <pre><code>from proxy import Nginx\n\nnginx = Nginx(max_requests=3)\n\nmsg1 = nginx.handle_request(\"google.com\")\nmsg2 = nginx.handle_request(\"google.com\")\nmsg3 = nginx.handle_request(\"google.com\")\nassert msg1 == \"WebServer handling request for: google.com\"\nassert msg2 == msg3 == \"Returning cached response for: google.com\"\nmsg4 = nginx.handle_request(\"google.com\")\nassert msg4 == \"Access denied\"\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// simulate requests\nfunc simulateRequests(nginx *Nginx, urls []string) {\n    for _, url := range urls {\n        fmt.Println(nginx.handleRequest(url))\n        time.Sleep(100 * time.Millisecond) // simulate delay between requests\n    }\n}\n\nfunc main() {\n    nginx := NewNginx(2)\n\n    urls := []string{\n        \"/home\",\n        \"/home\",\n        \"/home\", // should be denied\n        \"/about\",\n        \"/home\", // should be denied\n        \"/home\", // should be denied\n        \"/contact\",\n    }\n\n    simulateRequests(nginx, urls)\n}\n</code></pre>"}]}